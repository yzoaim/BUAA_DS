### 第一次作业整理

#### 1.拓展字符

【问题描述】
从键盘输入包含扩展符'-'的字符串，将其扩展为等价的完整字符，例如将a-d扩展为abcd，并输出扩展后的字符串。

要求：只处理[a-z]、[A-Z]、[0-9]范围内的字符扩展，即只有当扩展符前后的字符同时是小写字母、大写字母或数字，并且扩展符后的字符大于扩展符前的字符时才进行扩展，其它情况不进行扩展，原样输出。例如：a-R、D-e、0-b、4-B等字符串都不进行扩展。


【输入形式】
从键盘输入包含扩展符的字符串
【输出形式】
输出扩展后的字符串

【输入样例1】
ADEa-g-m02
【输出样例1】
ADEabcdefghijklm02

【输入样例2】
cdeT-bcd
【输出样例2】
cdeT-bcd

【样例说明】
将样例1的输入ADEa-g-m02扩展为：ADEabcdefghijklm02；样例2的输入cdeT-bcd中，扩展符前的字符为大写字母，扩展符后的字符为小写字母，不在同一范围内，所以不进行扩展。
【评分标准】
该题要求扩展字符，提交程序文件expand.c。

```c
#include<stdio.h>
#include<ctype.h>
int N = 100005;
int main(){
	char s[N];
	int i,j,k= 0;
	
	scanf("%s",s);
	for(i=0;i<strlen(s);){
		printf("%c",s[i]);
		if(s[i+1]=='-'){
			if((isupper(s[i])&&isupper(s[i+2]))||(islower(s[i])&&islower(s[i+2]))||(isdigit(s[i])&&isdigit(s[i+2]))){
				for(k = s[i]+1;k<s[i+2];k++){
					printf("%c",k);
				}
				i+=1;
			}
			else{
				i++;
				printf("%c",s[i]);
			}
		}
		i++;
	}
}
```

### 2.直接中缀表达式求值 无括号

【问题描述】

从标准输入中读入一个整数算术运算表达式，如5 - 1 * 2 * 3 + 12 / 2 / 2  = 。计算表达式结果，并输出。

要求：
1、表达式运算符只有+、-、*、/，表达式末尾的’=’字符表示表达式输入结束，表达式中可能会出现空格；
2、表达式中不含圆括号，不会出现错误的表达式；
3、出现除号/时，以整数相除进行运算，结果仍为整数，例如：5/3结果应为1。

【输入形式】

在控制台中输入一个以’=’结尾的整数算术运算表达式。

【输出形式】

向控制台输出计算结果（为整数）。

【样例1输入】

5 - 1 * 2 * 3 + 12 / 2 / 2  =

【样例1输出】

2

【样例2输入】

500 =

【样例2输出】

500

【样例1说明】

输入的表达式为5 - 1 * 2 * 3 + 12 / 2 / 2 =，按照整数运算规则，计算结果为2，故输出2。

【样例2说明】

输入的表达式为500 = ，没有运算符参与运算，故直接输出500。

算法之一提示：
1、可以利用gets函数，读取整行表达式；
2、对于空格，可以考虑首先去除表达式中的所有空格
3、可以设一计数器用来记录已读取、但未参加运算的运算符的个数，根据该计数器来判断如何进行运算；
4、可以设计一函数：实现二元整数算术运算。

【评分标准】

该题要求输出整数表达式的计算结果，共有5个测试点。上传C语言文件名为example1c.c。

```c
#include<stdio.h>
#include<ctype.h>
#include<string.h>
#define N 10000
int i; 
int num[N];
char s[N],op[N];
int top1 = -1,top2 =-1 ;
int op_priority[500];
int x = 0;
void cal();
int main(){
	op_priority['+'] = 1;
	op_priority['-'] = 1;
	op_priority['*'] = 2;
	op_priority['/'] = 2;
	gets(s);
	int i,j;
	for(i=0,j=0;s[j]!='\0';){
		if(s[j]!= ' '){
			s[i] = s[j];
			i++,j++;
		}
		else{
			j++;
		}
	}//先把空格去掉，记得补'\0'
	s[i] = '\0';
//	for(int i = 0;s[i]!='\0';i++){
//		printf("%c",s[i]);
//	}//去掉空格
//	printf("\n"); 
    for(i = 0;s[i]!='=';i++){
        j = i;
        if(isdigit(s[j])){
            while(isdigit(s[j])){
                x = (s[j]-'0')+10*x;
                j++;
            }
            num[++top1] = x;// push x into num
//           printf("push %d : %d\n",top1,x);
        	i = j-1; 
			x = 0;   
        }//遇到数字，首先进行一步转化，然后入数字栈 
        else{//如果遇到操作符,当：操作符栈不为空且栈内优先级更高的话，栈外的压不进去，需要栈内的先出栈，才能入栈。
        	while(top2!=-1&&op_priority[s[i]]<=op_priority[op[top2]]){
        		cal();
        	}
			op[++top2] = s[i];//计算完毕，入栈
//			printf("top2:%d\n oprand:%c\n",top2,s[i]);
		}
	}
	while(top2!=-1){
//		printf("this time top2 = %d",top2);
		cal();//只要操作符栈不为空，继续计算
	}
	printf("%d\n",num[top1]);
}
//3 + 4*3/2 - 3*5 =  

void cal(){
	int b = num[top1--];
	int a = num[top1--];
	int res;
//	printf("a + b = res : %d\n",res);
	char oprand = op[top2--];
//	printf("oprand is %c",oprand);
	if(oprand == '+'){
		res = a + b;
//		printf("%d %c %d = %d",a,oprand,b,res);
	}
	else if(oprand == '-'){
		res = a-b;
	}
	else if(oprand == '*'){
		res = a*b;
	}
	else if(oprand == '/'){
		res = a/b;
	}
	num[++top1] = res;
}
```

##### 拓展:中缀表达式转后缀表达式-带括号-计算

```c
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#define N 500010
float num[N];
char s[N];
char op[N];
int i,j,t_num=-1,t_s=-1,t_op=-1;
int priority[256];
float x;
int number;
void eval();
int main(){
    priority['+']=1;
    priority['-']=1;
    priority['*']=2;
    priority['/']=2;
	gets(s);
	for(int i=0;i<strlen(s);i++){
		if(s[i]==' ')continue;
		else if(s[i]=='=') break;
		else if(isdigit(s[i])){
			number = 0,j = i;
            number = read_digit(s,j);
			num[++t_num] = number;
			i = j-1;
		}
		else if((s[i]=='(')){
			op[++t_op] = '(';
		}
		else if((s[i]==')')){
			while(op[t_op]!='('){
				eval();
			}
			t_op--;//把'('弹掉
		}
		else{
			while(t_op>-1&&priority[(int)op[t_op]]>=priority[(int)s[i]]) eval();//对比符号栈顶的元素与所获得的符号的优先级，栈内优先级高于栈外优先级
			op[++t_op] =s[i];//如果栈外优先级更高，入栈		
			}
	}
	while(t_op>=0) eval();
	printf("%.2f",num[t_num]);
}

int read_digit(char s[],int i){
    x=0,j=i;
    while(j<strlen(s)&&isdigit(s[j])){
        x = x*10+s[j]-'0';
        j++;
    }
    return x;
}
void eval(){
	float num2 = num[t_num--];
	float  num1 = num[t_num--];
	char opt = op[t_op--];
	if(opt=='+') num[++t_num] = num1+ num2;
	else if(opt=='-') num[++t_num] = num1- num2;
	else if(opt=='*') num[++t_num] = num1* num2;
	else if(opt=='/') num[++t_num] = num1/ num2;
}
//24/(1+5/3+36/6/2-2)*(12/2/2)=
//24/(1+5/3+ 36 /6/2-2)*( 12 / 2 / 2)  =

```

#### 表达式的转换：

- 中缀表达式转换为后缀表达式：
  - 1）如果遇到操作数，我们就直接将其输出。
  - 2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中，如果优先级不够高，则弹出栈内操作符直到栈内优先级小于栈外优先级
  - 出口：如果我们读到了输入的末尾，则将栈中所有元素依次弹出，栈内都为空

- 中缀表达式转换为前缀表达式：（实际上更像是转后缀的逆）

  - **从右到左**进行遍历。

  - 1.遇到的是运算数，直接输出。

  - 2.遇到的是右括号')'，直接压入堆栈(括号是最高优先级，无需比较；入栈后优先级降到最低，确保其他符号正常入栈)。

  - 3.遇到的是左括号'('，意味着括号已结束。不断弹出栈顶运算符并输出，直到遇到右括号，这个右括号弹出但是不输出。

  - 4.遇到的是运算符('+'、'-'、'*'、'/')，有三种情况

    - ①如果栈为空，直接入栈。
    - ②如果栈顶元素是右括号')'，直接入栈。
    - ③如果栈顶元素是运算符，则需要进行比较，
      - 1-如果优先级**大于等于**栈顶运算符，则压入堆栈；
      - 2-如果优先级**小于**栈顶运算符，则将栈顶运算符弹出并输出，然后比较新的栈顶运算符，直到优先级大于等于栈顶运算符或者栈空，再将该运算符入栈

    5.如果对象处理完毕，则按顺序弹出并输出栈中所有运算符

表达式计算方法:

- 中缀表达式计算
  - 遇到数字则入数字栈
  - 遇到操作符时，若栈外操作符优先级大于栈内操作符，入栈。(相同的优先级，栈内操作符优先级更大)
  - 若栈外操作符优先级小于等于栈内操作符，栈内操作符先出栈，再入栈栈外操作符。
  - 注意操作栈内元素出栈的时候，数字栈也要出栈两个元素进行运算，先取到的是b，然后取到a，计算a op b
  - 出口是数字栈应该只剩一个元素。



前缀表达式：从后往前扫，遇到操作数入栈、遇到字符时取两栈顶元素进行相应运算后结果入栈。

后缀表达式：与上类似，只是是从前往后扫。只要遇到操作符，就把数字栈的两个出栈运算，再放进去。

### 全排列数的生成

拓展:

1. 生成从m到n之间的所有全排列

```c
#include<stdio.h>
int val[30];
char vis[30];
int n,l,r;
void dfs(int x){
	if(x>n){
		for(int i=1;i<=n;i++){
			printf("%d ",val[i]);
		}
		printf("\n");
		return ;
	}
	for(int i = l; i<= r;i++){
		if(vis[i])
			continue;
	vis[i] = 1;
	val[x] = i;
	dfs(x+1); 
	vis[i] = 0;
	val[x] = 0;
	//初始化 
	}
}
int main(){
	scanf("%d %d",&l,&r);
	n = r-l+1;//个数 
	dfs(1);// 第一个输出的数 
	return 0;
}
// dfs(1)指的是要从第一层开始
//对[l,r]之间的排列






```



1. ```c
   #include <stdio.h>
   void swap(int a[], int p, int q);
   void perm(int a[], int p, int q);
   int main(){
    int num[55];
    int i, n, m;
    scanf("%d%d", &n, &m);
    for (i = 0; i < m - n + 1; i++)
    {
   	num[i] = i + n;
    }
    perm(num, 0, m - n);
    return 0;
    }
   void swap(int a[], int p, int q){//锟街碉拷锟津交伙拷
   int i, temp;
   	if (p < q){
   		temp = a[q];
   		for (i = q; i > p; i--)
   		{
   		a[i] = a[i - 1];
   		}
   		a[p] = temp;
   	}
   	else if (p > q){
   	temp = a[q];
   	for (i = q; i < p; i++)
   	{
   	a[i] = a[i + 1];
   	}
   	a[p] = temp;
   	} 
   }
   void perm(int a[], int p, int q){ //全锟斤拷锟叫猴拷锟斤拷
    int i;
    if (p == q)
   	 {
   	 for (i = 0; i <= q; i++)
   	 {
   	 printf("%d ", a[i]);
   	 }
   	 printf("\n");
   	 return;
    }
   	 for (i = p; i <= q; i++)
   	 {
   	 swap(a, p, i);
   	 perm(a, p + 1, q);
   	 swap(a, p, i);
   	 } 
    }
    
   ```
   
2. 

1. 从1-n这n个数里面选m个的全排列

```c
#include <stdio.h>
int vis[10] = {0},result[10] = {0};
int m,n;
void dfs(int k){
    int i;
    if(k == m){
        for(i = 0;i < m;i++){
            printf("%d ",result[i]);
        }
        putchar('\n');
        return;
    }
    else{
        for(i = 1;i <= n;i++){
            if(!vis[i]){
                vis[i] = 1;
                result[k] = i;
                dfs(k + 1);
                //result[k] = 0;
                vis[i] = 0;
            }
        }
    }
}
int main(int argc,char **argv){
    scanf("%d%d",&n,&m);
    dfs(0);
    return 0;
}

```



1. 从m个里面选n个的组合



### 第二次作业

## 2.1 五子棋危险判断

【问题描述】

已知两人分别执白棋和黑棋在一个围棋棋盘上下五子棋，若同一颜色的棋子在同一条横行、纵行或斜线上连成5个棋子，则执该颜色棋子的人获胜。编写程序读入某一时刻下棋的状态，并判断是否有人即将获胜，即：同一颜色的棋子在同一条横行、纵列或斜线上连成4个棋子，且该4个棋子的两端至少有一端为空位置。
输入的棋盘大小是19×19，用数字0表示空位置（即没有棋子），用数字1表示该位置下了一白色棋子，用数字2表示该位置下了一黑色棋子。假设同一颜色的棋子在同一条横行、纵列或斜线上连成的棋子个数不会超过4个，并且最多有一人连成线的棋子个数为4。

【输入形式】

从控制台输入用来表示棋盘状态的数字0、1或2；每行输入19个数字，各数字之间以一个空格分隔，每行最后一个数字后没有空格；共输入19行表示棋盘状态的数字。

【输出形式】

若有人即将获胜，则先输出即将获胜人的棋子颜色（1表示白色棋子，2表示黑色棋子），然后输出英文冒号:，最后输出连成4个棋子连线的起始位置（棋盘横行自上往下、纵列自左往右从1开始计数，**横行最小的棋子在棋盘上的横行数和纵列数作为连线的起始位置**，若在同一行上，则**纵列数最小的棋子**位置作为起始位置，两数字之间以一个英文逗号,作为分隔符）。
若没有人获胜，则输出英文[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)：No。
无论输出什么结果，最后都要有回车换行符。

【输入样例1】

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 2 0 1 1 2 0 0 0 0 0 0 0
0 0 0 0 0 2 1 1 1 1 2 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 2 1 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 1 0 2 2 0 0 0 0 0 0 0 0
0 0 0 0 0 2 0 1 0 0 2 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

【输出样例1】

1:9,8

【输入样例2】

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

【输出样例2】

No

【样例说明】

在输入的样例1中，执白棋（数字1表示）的人即将获胜，连成4个棋子且有一端为空的起始位置在第9行第8列，所以输出1:9,8。
在输入的样例2中，还没有同一颜色的棋子连成4个，所以无人即将获胜，直接输出No。





### 第三次作业



#### 多项式相乘

```c
#include<stdio.h> 
#include<stdlib.h>
typedef struct Node *Poly;
struct Node{
    long long coe; 
    long long exp;   
    Poly next;
};
char line1[100000];
char line2[100000];
Poly p,ps,p1,p2,ps1,ps2,t,end,q;
int n,m;
long long x,y;
long long num;
int main(){
	p1 = (Poly)malloc(sizeof(struct Node));
	p2 = (Poly)malloc(sizeof(struct Node));
    p1->next = NULL;
    p2->next = NULL;
	ps=p1;
	Poly newPoly;
	char op;
	do{
		scanf("%lld%lld%c",&x,&y,&op);
		newPoly =(Poly)malloc(sizeof(struct Node));
        newPoly->coe = x;
        newPoly->exp = y;
        newPoly->next = NULL;
        ps->next = newPoly;
       	ps=ps->next;
	}while(op!='\n');//第一行输入 
	ps = p2;
	do{
		scanf("%lld%lld%c",&x,&y,&op);
		newPoly = (Poly)malloc(sizeof(struct Node));
        newPoly->coe = x;
        newPoly->exp = y;
        newPoly->next = NULL;
        ps->next = newPoly;
       	ps=ps->next;
	}while(op!='\n');//第二行输入 
	
    p = (Poly)malloc(sizeof(struct Node));// Poly
    
    p->next = NULL;//
    
    ps1=p1->next;
    ps2=p2->next;
    
	end=p;
	
    int flag=1;//
    
	while (ps1 != NULL){
    	ps2=p2->next;
        while (ps2 != NULL){
            long long c, e;
            c = ps1->coe * ps2->coe;
            e = ps1->exp + ps2->exp;
//            if (flag){
//                flag = 0;//？ 
//                t = (Poly)malloc(sizeof(struct Node));//
//                t->coe = c;
//                t->exp = e;
//                t->next = NULL;//
//                end->next = t;//
//                end = end->next;
//            }
                q = p;//p是输出的链头，q是输出链的移动指针
            //p1,p2分别为第一、二条输入链
            //ps1,ps2为第一二条输入链的移动指针
                while (q->next != NULL&&q->next->exp > e){
                    q = q->next;//只要大于，就继续移动,以便把exp插入到小于e的地方
                }//降序排列                   
                if (q->next!=NULL&&q->next->exp == e){//系数相同，看相加后会不会等于0
                    if (q->next->coe+c==0)
                    {
                        q->next = q->next->next;
                    }
                    else{
                    	q->next->coe=q->next->coe+c;
					}
                }//合并相同系数并且去掉 coe = 0 的情况 
                else{
               	//如果没有相同的指数，直接把t插入q后面，实现了
                    t = (Poly)malloc(sizeof(struct Node));
                    t->coe = c;
                    t->exp = e;
                    t->next = q->next;
                    q->next = t;
                }
            ps2=ps2->next;//下一个
        }
        ps1=ps1->next;
    }
    ps=p->next;//p是空的链头。
    while (ps != NULL){
        printf("%lld %lld ", ps->coe, ps->exp);
        ps=ps->next;
    }//最后结果是ps 
}



//	while(scanf("%c",&x)!='\n'){
//		if(!done1)
//		{
//			if(isdigit(x)){
//				num = num*10 + x - '0'; 
//			}
//			else if(isspace(x)){
//				done1 = 1;
//			}
//		}
//		else if(done1){
//			newPoly = (Poly)malloc(sizeof(struct Node));
//			if(!flag1){
//				x = num;
//	        	newPoly->coe = x;
//			}
//			else{
//				y = num;
//				newPoly->exp = y;
//			}
//			newPoly->next = NULL;
//	        ps->next = newPoly;
//	     	ps=ps->next;
//	     	flag1^=1;
//	     	done1 = 0;
//     	}
//	}
//	    ps=p2;
//	while(scanf("%lld",&num)!='\n'){
//		newPoly = (Poly)malloc(sizeof(struct Node));
//		if(!flag2){
//			x = num;
//        	newPoly->coe = x;
//		}
//		else{
//			y = num;
//			newPoly->exp = y;
//		}
//		newPoly->next = NULL;
//        ps->next = newPoly;
//     	ps=ps->next;
//     	flag2^=1;
//	}
//	for (int i = 0; i < n; i++)
//    {
//        scanf("%lld %lld", &x, &y);
//        newPoly = (Poly)malloc(sizeof(struct Node));
//        newPoly->coe = x;
//        newPoly->exp = y;
//        newPoly->next = NULL;
//        ps->next = newPoly;
//       	ps=ps->next;
//    }
//    ps=p2;
//    for (int i = 0; i < m; i++){
//        scanf("%lld %lld", &x, &y);
//        newPoly = (Poly)malloc(sizeof(struct Node));
//        newPoly->coe = x;
//        newPoly->exp = y;
//        newPoly->next = NULL;
//        ps->next = newPoly;
//       	ps=ps->next;
//    }
```

##### 此题的拓展-多项式相加

```c
#include <stdio.h>
#define N (200000 + 5)
long long a[N], b[N];
long long s[N], t[N];
void polyadd(long long a[],long long s[],int n,long long b[],long long t[],int m);
int main()
{
	 int n, m;
	 int p = 1, q = 1;
	 int i;
	 scanf("%d%d", &n, &m); 
	 for (i = 1; i <= n; i++)
	 scanf("%lld%lld", &a[i], &s[i]);
	 // 第一个狮子的系数和指数 
	 for (i = 1; i <= m; i++)
	 scanf("%lld%lld", &b[i], &t[i]);
	 //输出方法很重要
	polyadd(a,s,n,b,t,m);
	//不需要加了再输出！！
	//没有一样的指数 直接输出 
	// 有的话 相加再输出 一次。
	//	保证 降序
	 
 return 0;
}//可AC  
void polyadd(long long a[],long long s[],int n,long long b[],long long t[],int m){
	int p=1,q=1;
	while (p <= n || q <= m){
		if ((p <= n && q <= m && s[p] > t[q]) ){
			printf("%lld %lld ", a[p], s[p]);
			p++;
		}//由大到小 有大的就直接输出 先不要考虑扫描完了的情况 
		else if ((p <= n && q <= m && s[p] < t[q])){
			printf("%lld %lld ", b[q], t[q]);
			q++;// 由大到小 输出输出  谁大谁输出 
		}
////////////////////////////////////////////////////////
		else{	 // 分不出大小 即二者相等 
			if (a[p] + b[q] != 0)
			printf("%lld %lld ", a[p] + b[q], t[q]);
			p++, q++;//用于计数 
		}
	 }// 
}
```





#### 小型图书管理系统

问题描述】
小明同学特别喜欢买书看书。由于书较多，摆放杂乱，找起来非常麻烦。这学期小明同学上了数据结构与程序设计课后，决定改变这种状况：用C开发一个小型图书管理系统。系统中包含的图书信息有：书名、作者、出版社、出版日期等。首先，图书管理系统对已有的书（原始书库，存放在一个文本文件中）按书名字典序进行（按书名中各字符的ASCII码值由小到大排序）摆放（即将原始无序的图书信息文件生成一个有序的文件，即新书库），以便查找。该管理系统可以对新书库中图书条目进行如下操作：
1.录入。新增书录入到书库中（即从输入中读入一条图书信息插入到已排序好的图按书文件相关位置处）
2.查找。按书名或书名中关键字信息在书库中查找相关图书信息，若有多本书，按字典序输出。
3.删除。输入书名或书名中关键字信息，从书库中查找到相关书并将其删除，并更新书库。
【输入形式】
原始的图书信息（原始书库）保存在当前目录下的books.txt中。
用户操作从控制台读入，首先输入操作功能序号（1代表录入操作，2代表查找操作，3代表删除操作，0代表将已更新的图书信息保存到书库中并退出程序），然后在下一行输入相应的操作信息（录入操作后要输入一条图书信息，查找和删除操作后只要输入书名或书名中部分信息）。程序执行过程中可以进行多次操作，直到退出（输入操作0）程序。
要求：
1、原始文件中的图书信息与录入的图书信息格式相同，每条图书信息都在一行上，包括书名（不超过50个字符）、作者（不超过20个字符）、出版社（不超过30个字符）和出版日期（不超过10个字符），只由英文字母和下划线组成，用一个空格分隔。图书信息总条数不会超过500.
2、下划线字符参加排序。
3、图书不会重名。
【输出形式】
进行录入和删除操作，系统会更新图书信息，但不会在控制台窗口显示任何信息。
进行查找操作后，将在控制台按书名字典序分行输出查找到的图书信息，书名占50个字符宽度，作者占20个字符宽度，出版社占30个字符宽度，出版日期占10个字符宽度，都靠左对齐输出。
最终按字典排序的图书信息保存在当前目录下的ordered.txt中，每条图书信息占一行，格式与查找输出的图书信息相同。
【样例输入】
假设books.txt中保存的原始图书信息为：
The_C_programming_language Kernighan Prentice_Hall 1988
Programming_in_C Yin_Bao_Lin China_Machine_Press 2013
Data_structures_and_Algorithm_Analysis_in_C Mark_Allen_Weiss Addison_Wesley 1997
ANSI_and_ISO_Standard_c Plauger Microsoft_Press 1992
Data_structures_and_program_design_in_C Robert_Kruse Pearson_Education 1997
Computer_network_architectures Anton_Meijer Computer_Science_Press 1983
C_programming_guidelines Thomas_Plum Prentice_Hall 1984
Data_structures_using_C Tenenbaum Prentice_Hall 1990
Operating_system_concepts Peterson Addison_Wesley 1983
Computer_networks_and_internets Douglas_E_Come Electronic_Industry 2017
用户控制台输入信息为：
1
Data_structures_and_C_programs Christopher Addison_Wesley 1988
2
structure
1
The_C_programming_tutor Leon_A_Wortman R_J_Brady 1984
2
rogram
3
rogramming
0
【样例输出】
用户输入“2 structure”后，控制台输出：

![1.jpg](1522241979814085793.jpg)

用户输入“2 rogram”后，控制台输出：

![2.jpg](1522242028530059906.jpg)

ordered.txt文件内容为：
![3.jpg](1522242072422069649.jpg)

【样例说明】
先读入books.txt中的10条图书信息，按照书名进行字典序排序；用户进行了五次操作，然后退出：第一次操作是插入了一条图书信息，这时有11条图书信息，按书名字典序排序为：
ANSI_and_ISO_Standard_c Plauger Microsoft_Press 1992
C_programming_guidelines Thomas_Plum Prentice_Hall 1984
Computer_network_architectures Anton_Meijer Computer_Science_Press 1983
Computer_networks_and_internets Douglas_E_Come Electronic_Industry 2017
Data_structures_and_Algorithm_Analysis_in_C Mark_Allen_Weiss Addison_Wesley 1997
Data_structures_and_C_programs Christopher Addison_Wesley 1988
Data_structures_and_program_design_in_C Robert_Kruse Pearson_Education 1997
Data_structures_using_C Tenenbaum Prentice_Hall 1990
Operating_system_concepts Peterson Addison_Wesley 1983
Programming_in_C Yin_Bao_Lin China_Machine_Press 2013
The_C_programming_language Kernighan Prentice_Hall 1988
第二次操作是查找书名包含structure的图书，有4本图书信息按照格式要求输出到屏幕；第三次操作又插入了一条图书信息，这时有12条图书信息；第四次操作查找书名包含rogram的图书，有6本图书信息按照格式要求输出到屏幕；第五次操作是删除书名包含rogramming的图书信息，有四条图书信息要删除，剩下八条图书信息；最后退出程序前将剩余的八条图书信息按照格式要求存储在ordered.txt文件中。
【评分标准】

该程序要求编写图书管理系统。提交程序文件名为books.c。

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define N 1000
struct Lib{
	char name[N];
	char auth[N];
	char pub[N];
	int year;
	int deleted;
}lib[1000];
//char line[N][N];
//
int compare(const void *a,const void*b);
int main(){
	FILE *in;
	int op,j;
	int num;
	char str[N],substr[N];
	int i = 0;
	if((in = fopen("books.txt","r"))==NULL){
//		printf("fail to open\n");
	}
	else{
//		printf("y\n");
	}
	while(fscanf(in,"%s %s %s %d",lib[i].name,lib[i].auth,lib[i].pub,&lib[i].year)!=EOF){
//		printf("%d : %s %s %s %d\n",i,lib[i].name,lib[i].auth,lib[i].pub,lib[i].year);
		i++;
	}
	qsort(lib,i,sizeof(struct Lib),compare);
	while(scanf("%d",&op)!=0){
		if(op==0)
		break;
		else if(op == 1){
			scanf("%s %s %s %d",lib[i].name,lib[i].auth,lib[i].pub,&lib[i].year);
			i++;
			qsort(lib,i,sizeof(struct Lib),compare);
		}
		else if(op == 2){
			scanf("%s",substr);
			for(j = 0;j<i;j++){
				if(lib[j].deleted) continue;
				if(strstr(lib[j].name,substr)!=NULL){
					printf("%-50s%-20s%-30s%-10d\n",lib[j].name,lib[j].auth,lib[j].pub,lib[j].year);
				}	
			}
		}
		
		else if(op == 3){
			scanf("%s",substr);
			for(j = 0;j<i;j++){
				if(lib[j].deleted) continue;
				if(strstr(lib[j].name,substr)!=NULL){
					lib[j].deleted=1;
				}	
			}
		}
	}
	fclose(in);
	in = fopen("ordered.txt","w+"); 
	for(j = 0;j<i;j++){
		if(!lib[j].deleted)
		fprintf(in,"%-50s%-20s%-30s%-10d\n",lib[j].name,lib[j].auth,lib[j].pub,lib[j].year);
	}
	fclose(in);
}

int compare(const void *a,const void*b){
	struct Lib * x = (struct Lib*)a;
	struct Lib * y = (struct Lib*)b;
	return strcmp(x->name,y->name);
}
```

#### 字符串替换

【问题描述】

编写程序将一个指定文件中某一字符串替换为另一个字符串。要求：（1）被替换字符串若有多个，均要被替换；（2）指定的被替换字符串，大小写无关。

【输入形式】

给定文件名为filein.txt。从控制台输入两行字符串（不含空格，行末尾都有回车换行符），分别表示被替换的字符串和替换字符串。

【输出形式】

将替换后的结果输出到文件fileout.txt中。

【样例输入】

从控制台输入两行字符串：

in

out

文件filein.txt的内容为：

\#include <stdio.h>

void main()

{

  FILE * IN;

  if((IN=fopen("in.txt","r"))==NULL)

  {

​    printf("Can&rsquo;t open in.txt!");

​    return;

  }

  fclose(IN);

}

【样例输出】

文件fileout.txt的内容应为：

\#outclude <stdio.h>

void maout()

{

  FILE * out;

  if((out=fopen("out.txt","r"))==NULL)

  {

​    prouttf("Can&rsquo;t open out.txt!");

​    return;

  }

  fclose(out);

}

【样例说明】

输入的被替换字符串为in，替换字符串为out，即将文件filein.txt中的所有in字符串（包括iN、In、IN字符串）全部替换为out字符串，并输出保存到文件fileout.txt中。

【评分标准】

该题要求得到替换后的文件内容，共有5个测试点。上传C语言文件名为replace.c。

```c
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#define N 1000
//int __cdecl strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
// strnicmp比较str1,str2前n个的字典序
//char  *stristr (const char * str1,const char * str2);
//其实strstr就行；
char*  stristr(char * str1,char * str2);
char *strrpl(char *in, char *out, int outlen, const char *source, char *dest);
char s1[N],s2[N];
char line[N],outline[N];
int main(){
	scanf("%s",s1);
	scanf("%s",s2);
	FILE* in,*out;
	in = fopen("filein.txt","r");
	out = fopen("fileout.txt","w+");
	while(fgets(line,1011,in)!=NULL){
		if(stristr(line,s1)){
			strrpl(line,outline,N,s1,s2);
            //把line 里面的s1换成s2输出到outline
			fprintf(out,"%s",outline);
			memset(outline,0,N);			
		}
		else{
			fprintf(out,"%s",line);
		}
	}	
	fclose(in);
	fclose(out); 
}
 
char*  stristr(char * str1,char * str2){
    char *cp = (char *) str1;
    char *s1, *s2;
    if ( !*str2 ) 	
        return ((char*)str1);
    while (*cp){
        s1 = cp;
        s2 = (char *) str2;
        while ( *s1 && *s2 && toupper(*s1)==toupper(*s2) ){
            s1++, s2++;
        }//
        
        if (!*s2)
            return(cp);
        // 返回首地址 
        cp++;
    }
    //否则，则没有找到 
    return(NULL);
}
char *strrpl(char *in, char *out, int outlen, const char *src, char *dst)
{//string replace函数 
    //src input
    //dst output i need
//    strrpl(line,outline,N,s1,s2);
            //把line 里面的s1换成s2输出到outline
    char *p = in;//输入的需要进行操作的函数 
    unsigned int  len = outlen - 1;
    if((NULL == src) || (NULL == dst) || (NULL == in) || (NULL == out)||(strcmp(in, "") == 0) || (strcmp(src, "") == 0)||outlen <= 0)
    {
        return NULL;
    }
    while((*p != '\0') && (len > 0)){//没到末尾 
        if(strnicmp(p, src, strlen(src)) != 0){
            //比如找"in"；
            //则从首字母开始每次找两个字母,发现没有找到，则：
            int n = strlen(out);
            out[n] = *p;
            out[n + 1] = '\0';//表示一个复制的过程
            p++;
            len--;//maxlen--
        }
        else
        {
            //如果找到了就把s2贴在后面,
            strcat(out,dst);
            p += strlen(src);//p跳过s1继续到后面找.
            len -= strlen(dst);
        }
    }
    return out;
}
int strnicmp(const char *dst,const char *src,int count)
{//表示在dst里面找src的前n个字母
   int ch1, ch2;
   do
   {
      if ( ((ch1 = (unsigned char)(*(dst++))) >= 'A') &&(ch1 <= 'Z') )
        ch1 += 0x20;
      if ( ((ch2 = (unsigned char)(*(src++))) >= 'A') &&(ch2 <= 'Z') )
        ch2 += 0x20;
   } while ( --count && ch1 && (ch1 == ch2) );
   return (ch1 - ch2);
}


char *replace(char line[ ], char in[ ],char out[ ],char line1[ ])
{
    int i, j, k, l;
    int len_in,len_out;
    len_in=strlen(in);//被替换的字符串长度
    len_out=strlen(out);//替换字符串长度
    for(i=0,l=0 ; line[i] != '\0'; i++,l++){
        for(j=i,k=0;in[k]!='\0'&&tolower(line[j])==tolower(in[k]); j++,k++)
        ;
        if(in[k] == '\0'){
            strcat(line1, out);
            i=i+len_in-1;
            l=l+len_out-1; 
        }
        else
            line1[l]=line[i];
            //i是字符串起始点
    }
    return line1;
}
```

```c
struct Wordlist{
    char word[100];
    int count;
}wordlist[1000];

char article[10000];
char s[20000];

void initiate(){
    for(i=0;i<1000;i++)
    {
        memset(wordlist[i],0,sizeof(wordlist.word));
        wordlist[i].count = 0;
    }
}
void Getarticle(FILE* in,char s[]){
    in = fopen("article.txt","r");
    char *p = s;
    char c = 0;
    int i = 0;
    do{
        c = fgetc(in);
        if(c!=EOF){
        	s[i++]=c;    
        }
     }while(c!=EOF);
    for(j=0;j<i;j++){
        if(isupper(s[j])) s[j] = tolower(s[j]);
    }
    return p;
}// 获得数组
void getword(char *p){
    char temp[50];
    int i,j;
    for(i=0;i<strlen(p);i++){
		    if(isalpha(p[i])){
           		j = i+1;
                while(isalpha(p[j])){
                    j++;
                }
                memset(temp,0,sizeof(temp));
                for(k = 0;k<j-i;k++){
                    temp[k] = temp[k+i];
                }
                strcpy(wordlist[cnt].word,temp);
                wordlist[cnt].count = 1;
                cnt++;
            }
        	i = j;
     }
}

void counting(){
    qsort(wordlist,cnt,sizeof(struct Wordlist),cmp);
    for(i=0;i<cnt;i++){
            for(j=1;strcmp(wordlist[i].word,wordlist[i+j].word)==0;j++){
                	wordlist[i].count++;
           	}
        ans[total++] = wordlist[i];
    	i = j;
    }
    for(i=0;i<total;i++){
		FILE* out = fopen("out.txt","w");
        fprintf(out,"%s %d\n",ans[i].word,ans[i].count);
    }
}
int cmp(const void*a,const void*b){
	struct Wordlist *x  = (struct Wordlist*)a;
	struct Wordlist *y  = (struct Wordlist*)b;
    if(strcmp(x->word,y->word)>0) return 1;
    else if(strcmp(x->word,y->word)<0) return -1;
}

```



### 加密文件

```c
【问题描述】有一种加密方法为：其使用一个字母串（可以含重复字母，字母个数不超过50）作为密钥。假定密钥单词串为feather，则先去掉密钥单词中的重复字母得到单词串feathr，然后再将字母表中的其它字母以反序追加到feathr的后面：

 f	 e	 a	 t	 h	 r	 z	 y	 x	 w	 v	 u	 s	 q	 p	 o	 n	 m	 l	 k	 j	 i	 g	 d	 c	 b 
加密字母的对应关系如下：

 a	 b	 c	 d	 e	 f	 g	 h	 i	 j	 k	 l	 m	 n	 o	 p	 q	 r	 s	 t	 u	 v	 w	 x	 y	 z
 f	 e	 a	 t	 h	 r	 z	 y	 x	 w	 v	 u	 s	 q	 p	 o	 n	 m	 l	 k	 j	 i	 g	 d	 c	 b
其中第一行为原始英文字母，第二行为对应加密字母。其它字符不进行加密。编写一个程序，用这种密码加密文件。假定要加密的文件名为encrypt.txt及加密后的文件名为output.txt，并假定输入文件中字母全为小写字母，并且输入密钥也全为小写字母。

【输入形式】从标准输入中输入密钥串，并从文件encrypt.txt中读入要加密的内容。
【输出形式】加密后结果输出到文件output.txt中。
【样例输入】
feather
和文件encrypt.txt中内容，例如被加密的文件encrypt.txt中内容为：
c language is wonderful.
【样例输出】加密后output.txt文件中内容为：
a ufqzjfzh xl gpqthmrju.
【样例说明】首先将给定的密钥单词去除重复字母，然后按照上面的加密对应表对encrypt.txt文件内容进行加密即可得到加密后的文件，其中只对英文字母进行加密对换，并且假设encrypt.txt中的英文字母全是小写字母。

【评分标准】该题要求对文件进行加密，共有5个测试点。提交程序名为encrypt.c
```





























### 第三次作业



#### 连续线段

| 问题描述】 平面上两个点（一个点由(x,y)坐标组成）可构成一个线段，两个线段如果有一个端点相同，则可构成一个连续线段。假设构成线段的两个端点为v1(x1,y1)和v2(x2,y2)，在此满足x1<x2，其中v1称为线段的起点，v2为线段的终点。同样，对于连续线段来说，在此满足xi<xi+1（i=1...n-1，n为连续线段中的端点数，xi为相应端点的X轴坐标）。输入一组线段（用两个端点的x、y坐标表示线段，线段个数大于等于2，小于等于100），编程计算出连续线段中包含最多线段数的线段，输出相应的线段数和起点位置（注意，不是最长的连续线段，是包含最多线段的连续线段）。例如：![1.jpg](https://judge.buaa.edu.cn/userfiles/image/152144466177607998920.jpg)上图中有10个线段，其中5、10、4号线段连成了一条连续线段，线段数3条，起点位置为5号线段的左端点；6、8、2、3、9号线段连成了另一条连续线段，该连续线段包含的线段数最多，为5条，起点位置是6号线段的左端点。 注意： 1）不考虑线段中间相交的情况； 2）不会有三条或三条以上的线段共一个端点； 3）只会出现一条包含最多线段的连续线段；【输入形式】 先从控制台输入线段数，然后从下一行开始分行输入各线段两个端点的x、y坐标，其中第一个端点的X轴坐标小于第二个端点的X轴坐标，即x1<x2，x、y坐标都用整数表示，不会超过int的表示范围。各整数坐标值间以一个空格分隔。 【输出形式】 先在控制台输出包含最多线段数的连续线段的线段数，然后输出连续线段的起点的x、y坐标，输出数据**都以一个空格分隔**。 【样例输入】 1080 75 125 7560 40 80 5580 55 90 20140 120 195 20510 111 70 16522 35 43 4322 175 80 20543 43 60 4090 20 125 6070 165 140 120【样例输出】 5 22 35 【样例说明】 输入了十个线段，第一个线段两个端点分别为(80,75）和(125,75），其它线段类似，如上图所示，这些线段所构成的连续线段中包含最多线段数的连续线段的线段数为5，起点为(22,35），所以输出：5 22 35。 【评分标准】 通过所有测试点将得满分。提交程序名为line.c。 | 20   |
| ------------------------------------------------------------ | ---- |
|                                                              |      |



```c
#include <stdio.h>
#include <stdlib.h>
struct Line {
	int x1,y1,x2,y2;
};
int compare(const void *a, const void*b);
int main()
{
    struct Line line[500];
    int n=0;
    int i=0,j=0;
    int cnt =1,mcnt = 0;
    scanf("%d",&n);
    for(i=0;i<n;i++){
    scanf("%d %d %d %d",&line[i].x1,&line[i].y1,&line[i].x2,&line[i].y2);
	}
    qsort(line,n,sizeof(struct Line),compare);
//    printf("\n");
//    for(i=0;i<n;i++){
//    printf("%d %d %d %d\n",line[i].x1,line[i].y1,line[i].x2,line[i].y2);
//	}
    int mx1 = 0,my1= 0;
    for(i=0;i<n;i++){
    	int x2 = line[i].x2;
    	int y2 = line[i].y2;
    	cnt = 1;
    	for(j=i+1;j<n;j++){
//    		printf("line :%d %d %d %d\n",line[j].x1,line[j].y1,x2,y2);
    		if(line[j].x1==x2 && line[j].y1==y2){ 
                //找：下一条线段的起始点与我的终点相等的情况，并入。
    			cnt++;
    			x2 = line[j].x2;
    			y2 = line[j].y2;
                //然后,这条线段的终点就是我连续线段的终点
//    			printf("%d %d %d %d\n",mx1,my1,x2,y2);
			}
			if(cnt>mcnt){
				mcnt = cnt;
				mx1 = line[i].x1;
				my1 = line[i].y1;
			}
		}
	}
	printf("%d %d %d\n",mcnt,mx1,my1);
    return 0;
}

int compare(const void *a, const void*b){
	struct Line* x = (struct Line*)a;
	struct Line* y = (struct Line*)b;
	if(x->x1>y->x1){
		return 1;
	}
	else if(x->x1<y->x1){
		return -1;
	}
	else
	return x->y1-y->y1;
}
```





#### 最佳空间适应

在操作系统中，空闲存储空间通常以空闲块链表方式组织，每个块包含块起始位置、块长度及一个指向下一块的指针。空闲块按照存储位置升序组织，最后一块指向第一块（构成循环链表）。当有空间申请请求时，按照如下原则在空闲块循环链表中寻找并分配空闲块：

1）从当前位置开始遍历空闲块链表（初始是从地址最小的第一个空闲块开始），寻找满足条件的最小块（即：大于等于请求空间的最小空闲块，如果有多个大小相同的最小空闲块，则选择遍历遇到的第一个空闲块）（最佳适应原则）；

2）如果选择的空闲块恰好与请求的大小相符合，则将它从链表中移除并返回给用户；这时当前位置变为移除的空闲块指向的下一空闲块；

3）如果选择的空闲块大于所申请的空间大小，则将大小合适的空闲块返回给用户，剩下的部分留在空闲块链表中；这时当前位置仍然为该空闲块；

4）如果找不到足够大的空闲块，则申请失败；这时当前位置不变。

例如：下图示例给出了空闲块链表的初始状态，每个结点表示一个空闲块，结点中上面的数字指空闲块的起始位置，下面的数字指空闲块的长度，位置和长度都用正整数表示，大小不超过int表示范围。当前位置为最小地址为1024的空闲块。

![1615884927107062693.jpg](161588492710706269346.jpg)

若有4个申请空间请求，申请的空间大小依次为：1024、2560、10240和512。则从当前位置开始遍历上图的链表，按照上述原则寻找到满足条件的最小块为地址是16384的空闲块，其长度正好为1024，所以将其从链表中删除，这时链表状态如下图所示，当前位置变成地址为32768的空闲块。

![1615884927116013030.jpg](161588492711601303046.jpg)

从当前位置开始为第二个空间请求（大小为2560）遍历链表，按照上述原则寻找到满足条件的最小块为地址是80896的空闲块，其长度为3072，大于请求的空间大小，于是申请空间后该空闲块剩余的长度为512，当前位置为地址是80896的空闲块，链表状态如下图所示：

![1615884927126035010.jpg](161588492712603501046.jpg)

从当前位置开始为第三个空间请求（大小为10240）遍历链表，遍历一圈后发现找不到足够大的空闲块，则忽略该请求，当前位置不变。下面继续为第四个空间请求（大小为512）遍历链表，按照上述原则寻找到满足条件的最小块为当前位置的空闲块，其长度等于请求的空间大小，于是将该空闲块删除后，链表状态变为下图所示：

![1615884927159049659.jpg](161588492715904965946.jpg)

编写程序，模拟上述空闲空间申请。

【输入形式】

先从控制台读入一正整数，表示当前空闲块的个数（大于0且小于等于100）。

然后按照起始位置由小到大的顺序分行输入每个空闲块的起始位置和长度，位置和长度都用正整数表示，大小不超过int表示范围，两整数间以一个空格分隔。

最后在新的一行上依次输入申请空间的大小，以-1表示结束，各整数间以一个空格分隔，申请请求的个数不超过100个。

【输出形式】

按照上述原则模拟完空闲空间申请后，输出当前空闲空间链表状态，即从当前位置开始，遍历链表，分行输出剩余空闲块的起始位置和长度，位置和长度间以一个空格分隔。若申请完后，链表中没有空闲块，则什么都不输出。
【样例输入】

12

1024 2048

8192 512

16384 1024

32768 8192

65536 8192

77824 1024

80896 3072

86016 1024

91136 5120

99328 512

104448 1024

112640 3072

1024 2560 10240 512 1024 6400 512 -1
【样例输出】

104448 1024

112640 3072

1024 2048

8192 512

32768 1792

65536 8192

77824 1024

91136 5120
【样例说明】

样例输入了12个空闲块的信息，形成了如上述第一个图所示的空闲块链表；然后读取了7个空间申请请求，为前4个申请请求分配空间后，空闲块链表状态为上述最后一张图所示。满足第五个请求后，将删除地址为86016的空闲块；满足第六个请求后，地址为32768的空闲块剩余长度为1792；满足第七个请求后，将删除地址为99328的空闲块，这时链表中剩余8个空闲块，当前位置为地址是104448的空闲块，从该空闲块开始依次遍历输出所有剩余空闲块的起始位置和长度。
【评分标准】

该题要求编程模拟实现空闲空间的申请，提交程序名为memory.c。

```c
#include<stdio.h>
#include<stdlib.h>
#define min(a,b) a<b?a:b
struct Node{
	int pos;
	int space;
	struct Node* next;
};
typedef struct Node * PNode;
int main(){
	int n,i,a,b,deleted=0,cnt;
	int mspace,larger;
	int deleted1;
	int req[10005],reqnum;
	PNode p,q,h=NULL,current;
	scanf("%d",&n);
//	printf("%d\n",n);
	for(i=0;i<n;i++){
		q = (PNode)malloc(sizeof(struct Node));
		scanf("%d %d",&a,&b);
//		printf("%d %d\n",a,b);
		q->pos = a;
		q->space = b;
		if(h==NULL){
			h = p = q;
		}
		else{
			p->next = q;
			p = p->next;
		}
	}
	p->next = h;
	q = p;
	p = p->next;
	// 创建循环链表 
//	for(p = h;p->next!=h;p=p->next){
//		printf("%d %d\n",p->pos,p->space);
//	}
	//创建循环链表 
//	printf("%d %d\n",p->pos,p->next);
//	p=p->next;
//	printf("%d %d\n",p->pos,p->next);
	i = 0;
	while(scanf("%d",&req[i])){
//		printf("%d\n",req[i]);
		if(req[i]==-1)break;
		i++;
	}
	reqnum = i;
	current = p;
//	for(int i =0;i<reqnum;i++){	
//	printf("%d ",req[i]);
//	}//读入rq 
//	printf("\n");
//	printf("reqnum:%d\n",reqnum);
//	printf("currtn:%d %d\n",current->pos,current->space); 
	for(int i =0;i<reqnum;i++){	
//		printf("this time req = %d\n",req[i]);
		mspace = 0x7fffffff;
		larger = 0;
		deleted1 = 0;
		for(cnt = 0;cnt <= n-deleted-1;cnt++,q = p,p=p->next){
//			printf("p->pos:%d p->space:%d\n",p->pos,p->space);
			if(p->space == req[i]){
				q->next = p->next;
//				printf("in %d delete:%d\n",p->pos,p->space);
				free(p);
				deleted++;
				deleted1 = 1;
				p = q->next;
				current = p;
				break;
			}//恰好相等，删除 
			if((p->space )> req[i]){
				mspace = min(mspace,p->space);
				larger = 1;
			}
		}
		//重点在于：循环链表的建立以及删除。
		 
		if(larger==1&&!deleted1){//有更大的,且没有删除过节点，说明需要从结点中减掉一个space 
//			printf("min_spaceneed:%d\n",mspace);
			for(cnt = 0;cnt<=n-deleted-1;cnt++,q = p,p=p->next){
				if(p->space == mspace){
					p->space=p->space-req[i];
					if(p->space == 0){
						q->next = p->next;
						free(p);
						p = q->next;
						deleted++;
					}//如果刚好减掉后space==0，需要删除节点。 
//					printf("in %d substract and get:%d\n",p->pos,p->space);
					current = p;
					break;
				}//找到第一个最小的，剪掉 
			}
		}
		current = p;
		//注意第二次req是从当前节点开始 
//			if(p->space == mspace){
//				p->space-=req[i];			
//				printf("in %d substract:%d\n",p->pos,p->space);
//				current = p;
//			}
	}
//	printf("\n");
//	printf("deleted:%d\n",deleted);
	for(p=current,cnt = 0;cnt<=n-deleted-1;cnt++,p=p->next){
		printf("%d %d\n",p->pos,p->space);
	}
//		printf("%d %d\n",p->pos,p->space);
}

```

#### 文件环加密

























```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h> 
typedef struct Node* PNode;
struct Node{
	char c;
	struct Node* next;
};
char table[130];
int used[130];
char key[50];
int main(){
	char ch,sr;
	int i;
	FILE *in,*out;
//	in = fopen("article.txt","r");
	PNode h,p,q,t;
	char org;
	p=q=h=NULL;
//	h = (struct Node*)malloc(sizeof(struct Node));
//	p = (struct Node*)malloc(sizeof(struct Node));
	fgets(key,50,stdin);
	//从标准输入读入密钥 
//	while((ch=fgetc(stdin))){
//		if(cnt>10)break;

	for(int i = 0;key[i]!='\n'&&key[i]!='\0';i++){
		q = (struct Node*)malloc(sizeof(struct Node));
		q->c = key[i];
		q->next  =NULL;
	//		printf("%c ",q->c);
//		cnt++;
			if(!used[key[i]-' ']){//ascii code:32-126,表示密钥中的i位是否被用过 
				used[key[i]-' ']=1;//没有用过就设置被用过 
				if(h==NULL){
					h=p=q;
//					h->next = NULL;
				}
				else{
					p->next =q;
					p=p->next;
					p->next = NULL;
				}//连接成链 
			}
			else continue;//被用过了就自动跳过 
	}
//	cnt = 0;
//	fclose(in);
	for(i = 32;i<=126;i++){
//		if(cnt>10)break;
		if(!used[i-32]){
			t = (struct Node*)malloc(sizeof(struct Node));
			t->c = (char)i;
//			printf("add:%-5c ",i);
			p->next = t;
			p=p->next;
			p->next = NULL; 
		}//再把不在密钥里的字符接在这条链的后面 
	}
	p->next = h;
    
    
	//最后构成一条循环的链 
//	p = p->next;// p is the head now.
//	printf("下面是原来的字符表\n"); 
//	for(p=h;p->next!=h;p=p->next){
//	//		printf("",i);
//			printf("%c",p->c);
//	//		i++;		
//	}
//	printf("%c",p->c);
//	printf("\n");
//	 p=h now
//	printf("%d:%c\n",i,p->c);
//	cnt = 0;
	q = p;
	p = h;
	sr = p->c;
	org = sr;
	//org起先的字符 
//	printf("%c",org);
	while(p!=p->next){//当只剩最后一个的时候quit
		q->next = p->next;
		free(p);
		p = q->next;//首先删掉这一个节点 
//		for(i=sr-1;i>0;i--){
//			q=p,p=p->next;
//		}
//		//已经走了一次 
		for(i=0;i<(int)sr-1;i++){
				q=p,p=p->next;
				//然后走 [节点的ascii-code]次 
		}
		//sr 对应的密钥就是目前的char 
		table[(int)sr] = p->c;
		sr = p->c;
		//sr,下一次被删除的结点. 
	}
	
	table[(int)sr] = org;
//	最后，剩下的结点的密钥是最开始被删除的char.
//	于是得到了加密表table[]
 

 
//	printf("对应的加密表\n");
//	for(int i = 32;i<=126;i++){
//		printf("%c",table[i]);
//	}

	in = fopen("in.txt","r");
	out = fopen("in_crpyt.txt","w");
//	printf("\n");
	while(fscanf(in,"%c",&ch)!=EOF){
		if(ch>=32&&ch<=126){
			fprintf(out,"%c",table[(int)ch]);
//			printf("%c",table[(int)ch]);
		}
		else{
			fprintf(out,"%c",ch);
//			printf("%c",ch);
		}
//		cnt++;
//		if(cnt>50)break;
	}
	
	fclose(in);
	fclose(out);
    //难点在于：1.创建循环链表，删除，创造table.
//	printf("\n\n");
//	for(int i = 32;i<=126;i++){
//		printf("%c",i);	
//	}
////	printf("\n");
//	for(i=1,p=h;p->next!=h;p=p->next){
////		printf("",i);
//		printf("%c",p->c);
//		i++;		
//	}
////	 p=h now
//	printf("%d:%c\n",i,p->c);
//	p = p->next;
//	printf("now:%c",p->c);
////	
	return 0; 
}
```

#### 数组模拟链表

```c
#include<stdio.h>

void init(){
    idx = 0;
    head = -1;
}
int val[Max],ne[Max];
void insert_head(int x){
	val[idx] = x;
    ne[idx] = head;
    head = idx;
    idx ++;
}
void add(int k, int x){
    val[idx] = x;
    // 新建了一个节点，节点的val 为 x, 节点的索引为idx;
    ne[idx] = ne[k];
    ne[k] = idx;
}







```



#### 词频统计 利用数组







#### 词频统计

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#define N 50
struct Node{
	char words[N];
	int cnt;
	struct Node* next;
};
struct Node* wordlist = NULL;
char word[N];
int insert(struct Node* q, char * w){
	struct Node* newnode;
	newnode = (struct Node*)malloc(sizeof(struct Node));
	if(newnode == NULL)
	{
	  return -1;
	}
	strcpy(newnode->words,w);
	newnode->cnt = 1;
	newnode->next = NULL;
//	printf("newnode->words:%s, w: %s  ",newnode->words,w);
	if( q == NULL){
//		printf("2-1insert %s\n",newnode->words);	
		newnode->next = wordlist;
		wordlist = newnode;
//		printf("2insert %s\n",newnode->words);
	}//只有p一个的情况 
	else if(wordlist==NULL){
		wordlist = newnode;
//		printf("1insert %s\n",newnode->words);
	}//整个表都是空的情况 
	
	else{
//		printf("3-1insert %s\n",newnode->words);
		newnode->next = q->next;
		q->next = newnode;
//		printf("3insert %s\n",newnode->words);
	}//一般情况 
	return 0;
}

//void display(struct Node * head){
//	struct Node*p=NULL;
//	p = (struct Node*)malloc(sizeof(struct Node));
//	for(p = wordlist;p!=NULL;p = p->next){
//		printf("%s:%d\n",p->words,p->cnt);
//	}
//}

int search(struct Node* wordlist,char * w){
	struct Node*p;
	struct Node* q= NULL;
	p = (struct Node*)malloc(sizeof(struct Node));
//	q = (struct Node*)malloc(sizeof(struct Node));
//	if(q == NULL){
//		printf("yes null");
//	}
	for(p = wordlist;p!=NULL;q = p,p = p->next){
		if(strcmp(w,p->words)<0){
//				按升序排列,p字典序大于w
//				w应该插到q的后面 
				break;
		}
		else if(strcmp(p->words,w)==0) {
			p->cnt++;
//			找到了直接++ 
			return 1;
		}
	}
//	否则 w插入q的后面 
	return insert(q,w);
}
int getword(FILE* in, char *w){
	int c;
		while(isalpha(c = fgetc(in))==0){
			if(c == EOF) return -1;
		}
	do{
	*w++ = tolower(c);
//	*w = tolower(c); 
	//	w=w+1;
	} while(isalpha(c=fgetc(in))); 
	*w = '\0';
	return 0;
} //getword的时候要注意只接受字母。 
int main(){
	FILE * in ;
	in = fopen("article.txt","r");
	while(getword(in,word)!=-1){		
		search(wordlist,word);
//		printf("%s ",word);
	}
	struct Node*p=NULL;
	for(p = wordlist;p!=NULL;p = p->next){
		printf("%s %d\n",p->words,p->cnt);
	}
}
```







### 2020Mid

```c
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#include<stdlib.h>
struct line{
	char s[50];
	int deleted ;
	int repeated;
}Line[100];
int isdigit_str(char s[]){
	if(isdigit(s[0])){
		return 1;
	}
	return 0;
}

int compare(const void*a,const void*b){
	struct line* x = (struct line * )a; 
	struct line* y = (struct line * )b;
	if(x->deleted<y->deleted){
		return 1;//降序排列 
	}
	else if(x->deleted>y->deleted){
		return 0;
	}
	else{
		if(x->repeated<y->repeated){
			return 1;//降序排列 
		}
		else if(x->repeated>y->repeated){
			return 0;
		}
		else{
			if(strcmp(x->s,y->s)>0){
				return 1;
			}
			else{
				return 0;
			}
		}
	}
}
//把重复或者删除的都放在前面，后面的按照字典序排列 

int i,j,k,cnt;
int main(){
	char s1[10001];
	char s[10001];
	char t[10001];
	gets(s1);
	for(i=0;i<strlen(s1);i++){
		if(s1[i]==' '){
			continue;
//			s[j] = s1[i];
		}
		else{
			s[j] = s1[i];
			j++;
		}
	}
	s[j] = '\0';
	i=0,j=0;
//	puts(s);
	for(i=0;i<strlen(s);i++){
		if(isdigit(s[i])||isalpha(s[i])||s[i]=='_'){
			Line[cnt].s[j] = s[i];
			j++;
		}
		else if(j>0){
			Line[cnt].s[j] = '\0';
			cnt++;
			j=0;
		}
	}
	cnt++;
//去掉100i这样的并且去重 
//	for(i=0;i<cnt;i++){
//		printf("%s\n",Line[i].s);
//	}
	for(i=0;i<cnt;i++){
		if(isdigit_str(Line[i].s)){
			Line[i].deleted = 1;
		}
	}
	for(i=0;i<cnt;i++){
		for(j=i+1;j<cnt;j++){
			if(strcmp(Line[i].s,Line[j].s)==0){
				Line[j].repeated = 1;
			}
		}
	}
	qsort(Line,cnt,sizeof(Line[0]),compare);
//	printf("sucess\n");
//	for(i=0;i<cnt;i++){
//		printf("%s,deleted:%d repeated:%d\n",Line[i].s,Line[i].deleted,Line[i].repeated);
//	}
	for(i=0;i<cnt;i++){
		if(Line[i].deleted==0&&Line[i].repeated==0){
			printf("%s ",Line[i].s);
		} 
		else{
		continue;
		}
	}
	return 0;
	
}



//array_sum[i] = array_a[i] +array_a[j]+ _next2[ j ]getArea( x, y , z) - 100i

```

#### c语言标识符

标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线()组成的字符串，并且其第一个字符必须是字母或下划线



### 第五次作业总结

#### 第四题

```c
#include<stdio.h>
#include<stdlib.h>

struct Node{
	int flux;
	int idx;
	struct Node* left;
	struct Node* mid;
	struct Node* right;
	struct Node* next;
};
typedef struct Node newnode;
typedef struct Node* PNode;
int nodecnt = 0;
newnode Nodelist[1000];
//newnode p_num,p_char;
PNode Exptree[1000],root=NULL;
char huffcodetable[200][128];
void preorder(PNode node);
PNode Node_search(int x, PNode root);
//PNode root = NULL;
PNode p,q;
int totalnum;
int idx_arr[100],idx_cnt=0,layer_cnt=0;
struct Node* layerorder_arr[100];
void  layerorder(PNode root);

int cmp(const void*a,const void*b);
int main(){
	int b,a[1000],cnt,i,j,num;
	while(scanf("%d",&b),b!=-1){
		if(root==NULL){
			p = (PNode)malloc(sizeof(struct Node));
//			printf("b:%d ",b);
			p->idx = b;
			q = root = p;
			nodecnt++;
//			printf("root:%d ",root->idx);
		}
		else{	
	//		printf("root:%d",root->idx);
//			printf("to find %d",b);
			q = Node_search(b,root);
			if(q==NULL){
//				printf("not found\n");
			}
			else;
//			printf("b:%d,q:%d\n",b,q->idx);
		}
		while(scanf("%d",&a[cnt])&&a[cnt]!=-1){	
			if(a[cnt]<100) totalnum++;
				p = (PNode)malloc(sizeof(struct Node));
				p->idx = a[cnt];
				if(cnt==0){
					q->left=p;
//					printf("%d ",p->idx);
				}
				else if(cnt==1){
					q->mid = p;
//					printf("%d ",p->idx);
				}
				else if(cnt==2){
					q->right = p;
//					printf("%d ",p->idx);
				}
				cnt++;
//				printf("root:%d ",root->idx);
		}
//	printf("root:%d",root->idx);
//	printf("root:%d",q->idx);
//		for(i=0;i<cnt;i++){
//			printf("%d ",a[i]);
//		} 
		cnt = 0;
//		printf("\n");		
	}
	for(i=0;i<totalnum;i++){
		scanf("%d %d",&b,&num);
		q = Node_search(b,root);
		q->flux = num;
		q = NULL;
	}
//	printf("end\n");
	if(root!=NULL)
	layerorder(root);
//	printf("layerorder ended\n");
//	for(i=0;i<totalnum;i++){
//		printf("idx:%d-flux:%d\n",layerorder_arr[i]->idx,layerorder_arr[i]->flux);
//	}
	qsort(layerorder_arr,totalnum,sizeof(struct Node*),cmp);
//	for(i=0;i<totalnum;i++){
//		printf("idx:%d-flux:%d\n",layerorder_arr[i]->idx,layerorder_arr[i]->flux);
//	}
	for(i=0;i<totalnum;i++){
		printf("%d->%d\n",layerorder_arr[i]->idx,idx_arr[i]);
	}
//	preorder(root);
}



PNode Node_search(int x, PNode root){
	PNode t;
	t = root;
	if(t!=NULL){
		if(t->idx ==x){
			return t;
		}
		else{
			PNode tt = Node_search(x,t->left);
			if(tt==NULL){
				PNode tt = Node_search(x,t->mid);
				if(tt==NULL)	
				{
					PNode tt = Node_search(x,t->right);
				}
				else{
					return tt;
				}
			}
			else{
				return tt;
			}
		}
	}
	else return NULL;
	}
//Node*  searchBST(Node* t,int key)
//{//在 (root==t) 的子树里找 key
//      Node*  p=t;
//      while(p!=NULL){
//             if(key == p->data)  
//                  return p;       /* 查找成功 */
//             if(key > p->data)
//                  p=p->rchild; /* 将p移到右子树的根结点 */
//             else
//                  p=p->lchild; /* 将p移到左子树的根结点 */
//       }//循环找就行了
//       return NULL; /* 查找失败 */
//}

//void Texttoarr(FILE*in, struct Node sortedlist[]){
//	in = fopen()
//}
//
//void arrtominheap(struct Node sortedlist[]){
//	
//}
//
//void minheap_deleted{
//
//
//}
//
//void min_heapify(){
//	
//	
//	
//}
//
//void buildtree(){
//	
//}

void preorder(PNode node){
    //
	if(node!=NULL){
		printf("%d\n",node->idx);
		preorder(node->left);
		preorder(node->mid);
		preorder(node->right);
    }
}
void  layerorder(PNode root){
      PNode queue[100010];
	  struct Node* p;
      int h=0, t=-1;
      if(root!=NULL){
           queue[++t]=root;   
//          t=-1;     
//          h =0;
           while(h<=t){                      //若队列不空 
                 p=queue[h++];//出队  
                 if(p->idx<100){
                 	idx_arr[idx_cnt++] = p->idx;//表示层序遍历登机口的顺序
					layerorder_arr[layer_cnt++] = p;//稍后需要对其按照流量大小进行排序 
//                 	printf("id:%d,flux:%d\n",p->idx,p->flux);
				 }                    //访问p指结点
                 if(p->left!=NULL)           // 若左孩子非空 
                        queue[++t]=p->left;
                 if(p->mid!=NULL){
                 	queue[++t] = p->mid;
				 } 
				 if(p->right!=NULL)           //若右孩子非空 
                        queue[++t]=p->right;
           }
      }
}
int cmp(const void*a,const void*b){
	struct Node** x = (struct Node**)a;
	struct Node** y = (struct Node**)b;
	//注意列表里的元素是一级指针，qsort，cmp函数内对其调用则是二级指针
	//二级指针的取值就是一级指针的地址。 
	if((*x)->flux<(*y)->flux) return 1;
	else return -1;
}


//100 101 102 103 -1
//103 14 108 13 -1
//101 5 104 6 -1
//104 7 8 -1
//102 105 106 107 -1
//106 1 110 2 -1
//108 16 15 -1
//107 18 111 17 -1
//110 3 4 -1
//105 9 109 10 -1
//111 20 19 -1
//109 11 12 -1
//-1
//17 865
//5 668
//20 3000
//13 1020
//11 980
//8 2202
//15 1897
//6 1001
//14 922
//7 2178
//19 2189
//1 1267
//12 3281
//2 980
//18 1020
//10 980
//3 1876
//9 1197
//16 980
//4 576

```

##### 注意这道题中的几点：一个是对非BST的节点的查找，二是层序遍历与队列的应用，3是在qsort中的cmp函数需要。





### 哈夫曼树的构造

##### 关于getbits()

```c
unsigned getbits(unsigned x, unsigned p, unsigned n)
{
             return ( ( x >> (p + 1 – n)) & ~(~0 << n));
}
[从p位开始向右移p-n+1位]
|p|-----|p-n+1|------|
|-00000000000-|p-1  0|
|00000000000-1-000000|
|11111111111-0-111111|用1&把值取出来
```

### 第四次作业

#### 括号匹配

编写一程序检查C源程序文件中{}、()等括号是否匹配,并输出第一个检测到的不匹配的括号及所对应括号所在的行号（程序中只有一个括号不匹配）。

注意：

1. 除了括号可能不匹配外，输入的C源程序无其它语法错误。
2. 字符常量、字符串常量及注释中括号不应被处理，注释包括单行注释//和多行/* */注释
3. 字符常量和字符串常量中不包含转义字符’和"；
4. 程序中出现有意义括号的个数不超过200个；

不匹配判断规则：

1. 当检测的程序括号为’{‘时，若其前序尚未匹配的括号为’(‘时，输出该’('左括号及所在行号；
2. 当遇到一个不匹配的右括号’)‘或’}'时，输出该右括号及所在行号；
3. 当程序处理完毕时，还存在不匹配的左括号时，输出该左括号及所在行号。

【输入形式】

打开当前目录下文件example.c，查询其括号是否匹配。该文件中每行字符数不超过200。

【输出形式】

若存在括号不匹配时，应输出首先能判断出现不匹配的括号及其所在的行号。当出现括号不匹配时，按下面要求输出相关信息：

without maching at line

其中为‘{’, ‘}’， ‘(’, ‘)’等符号，为该符号所在的行号。

若整个程序括号匹配，则按下面所示顺序输出括号匹配情况，中间没有空格。

(){(()){}}

【样例输入1】

若当前目录下输入文件example.c中内容如下：

\#include<stdio.h>
int main(){
printf("{ hello world }\n"); // }
)

【样例输出1】

without maching ‘)’ at line 4

【样例输入2】

若当前目录下输入文件example.c中内容如下：

\#include<stdio.h>
int main(){
printf("{ hello world }d\n"); /* }*/

【样例输出2】

without maching ‘{’ at line 2

【样例输入3】

若当前目录下输入文件example.c中内容如下：

\#include<stdio.h>
int main(){
printf("{ hello world }d\n"); /* }*/
}

【样例输出3】

(){()}

【样例说明】

样例1：在注释部分和字符串中的括号不考虑，在将程序处理之后得到的括号序列是（）{（）），遇到右括号时与最近的左括号匹配，发现最后一个小括号和大括号不匹配。

样例2：处理之后的括号序列是（）{（），在最后缺少了右大括号，那么应该输出与之相对应的左括号不匹配。

```c
#include<stdio.h>
#define N 210
char line[N][N];
char s[10001],c,out[N];
int sline[10010];
int i=-1,j,k,t=-1,y,tt=-1;
int lcnt=1;
int main(){
	FILE* in;
	in = fopen("example.c","r");
	//
//	while((c=fgetc(in))!=EOF){
//		printf("%c",c);
//	}
	while((c=fgetc(in))!=EOF){
		if(c=='('){
			out[++i] = c; 
			s[++t] = c;
			sline[t] = lcnt;
		}// push
		else if(c=='{'){
			if(s[t]=='('){
				printf("without maching '%c' at line %d",s[t],sline[t]);
				return 0;
			}
			out[++i] = c; 
			s[++t] = c;
			sline[t] = lcnt;//{ line of {	
			
		}// push & check 
		else if(c==')'){
			if(s[t]=='('){
				out[++i] = c;
				t--;
//				tt--;	
			}
			else{
				printf("without maching '%c' at line %d\n",c,lcnt);
				return 0;
			}//不匹配 
		}
		else if(c=='}'){
			if(s[t]=='{'){
				out[++i] = c;
				t--;
//				tt--;	
			}
			else{
				printf("without maching '%c' at line %d\n",c,lcnt);
				return 0;
			}
		}
		else if(c=='/'){
			if((c=fgetc(in)),c=='/'){
				while(c=fgetc(in),c!='\n'){
                    ;
                }
				lcnt++;
				continue;
			}//
			else if(c=='*'){
				while((c=fgetc(in),c!='*')&&(c=fgetc(in),c!='/')){
			/* while((c1=fgetc(in),c1!='*')&&(c2=fgetc(in),c2!='/')){
                	if(c1=='\n'||c2=='\n') lcnt++;   
                }*/
                    if(c=='\n'){
						lcnt++;
					}
				}
				continue;
			}/* */
		}
		else if(c=='\''){
            while (c=fgetc(in),c!='\'') ;
            continue;
        }// 处理单引号
        else if(c=='\"'){
            while (c=fgetc(in),c!='\"') ;
            continue;
        } 
        if(c=='\n') lcnt++;
	}//处理 双引号
	if(t>-1){
		while(s[t]!='('&&s[t]!='{'){
			t--;
		}
		printf("without maching '%c' at line %d\n",s[t],sline[t]);
		return 0;
	}
	puts(out);
}
		
//不匹配判断规则：
//1.当检测的程序括号为'{'时，若其前序尚未匹配的括号为'('时，输出该'('左括号及所在行号； 
//2.当遇到一个不匹配的右括号')'或'}'时，输出该右括号及所在行号；
//3.当程序处理完毕时，还存在不匹配的左括号时，输出该左括号及所在行号。

//读入右括号时直接匹配。 




```

#### 表达式计算 -浮点数-有括号

```c
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#define N 500010
float num[N];
char s[N];
char op[N];
int i,j,t_num=-1,t_s=-1,t_op=-1;
int priority[256];
float x;
void eval();
int main(){
    priority['+']=1;
    priority['-']=1;
    priority['*']=2;
    priority['/']=2;
	gets(s);
	for(int i=0;i<strlen(s);i++){
		if(s[i]==' ')continue;
		else if(s[i]=='=') break;
		else if(isdigit(s[i])){
			x=0,j=i;
			while(j<strlen(s)&&isdigit(s[j])){
				x = x*10+s[j]-'0';
				j++;
			}
			num[++t_num] = x;
			i = j-1;
		}
		else if((s[i]=='(')){
			op[++t_op] = '(';
		}
		else if((s[i]==')')){
			while(op[t_op]!='('){
				eval();
			}
			t_op--;//把'('弹掉
		}
		else{
			while(t_op>-1&&priority[(int)op[t_op]]>=priority[(int)s[i]]) eval();//对比符号栈顶的元素与所获得的符号的优先级，栈内优先级高于栈外优先级
			op[++t_op] =s[i];//如果栈外优先级更高，入栈		
			}
	}
	while(t_op>=0) eval();
	printf("%.2f",num[t_num]);
}
void eval(){
	float num2 = num[t_num--];
	float  num1 = num[t_num--];
	char opt = op[t_op--];
	if(opt=='+') num[++t_num] = num1+ num2;
	else if(opt=='-') num[++t_num] = num1- num2;
	else if(opt=='*') num[++t_num] = num1* num2;
	else if(opt=='/') num[++t_num] = num1/ num2;
}
//24/(1+5/3+36/6/2-2)*(12/2/2)=
//24/(1+5/3+ 36 /6/2-2)*( 12 / 2 / 2)  =

```

##### 银行模拟

```c
#include<stdio.h>
#define N 10000
struct P{
	int id;
	int time;//等待时间
	int nd;//所需事件
}q[N],wt_ck[5],ept;
//struct P q[N];
int ckcnt=0;
int h=0,t=-1;
int idcnt=0;
int i,j,k,n,m;
//int wt_ck[5];//chuangkou
//int q[N];
int sr[N];
int op = 3;
double ave;
int wait_time[1000] = {0};
int main(){
	scanf("%d",&n);
//	printf("%d\n",n);
	for(i=0;i<5;i++){
		wt_ck[i].nd = 0;
		wt_ck[i].time = 0;
		wt_ck[i].id = 0;
	} 
	for(i=0;i<n;i++){
		scanf("%d",&sr[i]);
//		printf("%d",sr[i]);
		
	}
//	printf("\n");
	for(i=0;i<n;i++){
		for(j=0;j<sr[i];j++){
			++t;
			scanf("%d",&q[t].nd);
//			printf("%d ",q[t].nd);
			idcnt++;
			q[t].id=idcnt;//从1开始编号
		}
//		printf("\n");
		// 新客户
        double ave = (double)(t-h+1.0)/op;

        
//        printf("bf ave:%lf \n",ave);
    		
	    if(wt_ck[0].time>0)wt_ck[0].time--;  
        if(wt_ck[1].time>0)wt_ck[1].time--;
        if(wt_ck[2].time>0)wt_ck[2].time--;
        if(wt_ck[3].time>0)wt_ck[3].time--;
        if(wt_ck[4].time>0)wt_ck[4].time--;
        
        if(ave>=7.0){
            if(op==3){
                op = 4;
            }
            else if(op ==4){
                op = 5;
            }
//            printf("now op = %d\n",op);
        }
        ave = (double)(t-h+1.0)/op;
        if(ave>=7.0){
            if(op==3){
                op = 4;
            }
            else if(op ==4){
                op = 5;
            }
//            printf("now op = %d\n",op);
        }
        
//        printf(" ave:%lf \n",ave);
       /* 
		if(((t-h+1)/op)>=21&&t-h+1<28){
			op = 4;
		}
		else if(t-h+1>=28){
			op = 5;
		}
		*/
       //人放进窗口,出队 
		//判断是否增加窗口 
        for(k=0;k<op;k++){
			if(wt_ck[k].time == 0&&h<=t){//窗口没人且队列不为空
				wt_ck[k].time = q[h].nd;
               // wt_ck[k].nd = q[h].nd;
				h++;
			}
		}
        
        
		
		ave = (double)(t-h+1.0)/op;
		
//        printf("aft ave:%lf \n",ave);
		//
		//遍历开着的窗口，队里的人出队
		//出队 等待的客户减少  马上判断是否减少窗口 
        if(ave<7.0){
            if(op==5){
                op = 4;
            }
            else if(op ==4){
                op = 3;
            }
//            printf("aft: op = %d\n",op);
        }
        

        
        /*
		if(t-h+1<28&&t-h+1>=21){
			op = 4;
		}
		else if(t-h+1<21){
			op = 3;
		}
		*/
		
        for(k=h;k<=t;k++){
            wait_time[q[k].id]++;
        }
        /*
		for(k=3;k<=4;k++){
			for(m=0;m<op;m++){
				if(wt_ck[k].nd!=0&&wt_ck[m].nd==0){
					wt_ck[m] = wt_ck[k];
					wt_ck[k] = ept;
					m=op-1;
				}
			}
			//该位置还有人且换不进去 
			if(wt_ck[k].nd!=0){
				q[wt_ck[k].id].time++;
			}
		}
		*/
		//恢复原来业务
		// 队列的人等待时间++；		
	}
	//当:所有新客户入队完毕
	while(h<=t){
		//下一次服务: 
		if(wt_ck[0].time>0)wt_ck[0].time--;  
        if(wt_ck[1].time>0)wt_ck[1].time--;
        if(wt_ck[2].time>0)wt_ck[2].time--;
        if(wt_ck[3].time>0)wt_ck[3].time--;
        if(wt_ck[4].time>0)wt_ck[4].time--;
        for(k=0;k<op;k++){
			if(wt_ck[k].time==0&&h<=t){
				wt_ck[k].time= q[h].nd;
				h++;
			}
		}
		
       ave = (t-h+1.0)/op;
       
//	   printf("before ave:%lf \n",ave);
		if(ave<7){
            if(op==5){
                op = 4;
            }
            else if(op ==4){
                op = 3;
            }
        }
		
//		printf("h = %d,t = %d\n",h,t);
        
//	   printf("aft:%lf \n",ave);
        
      
//        printf("now op = %d\n",op);
        //只关不开
        		
		//遍历开着的窗口
		if(h<=t)
     	for(k=h;k<=t;k++){
            wait_time[q[k].id]++;
        }
	}
	
	for(i=1;i<=h;i++){
		printf("%d : %d\n",i,wait_time[i]);
	}
	//读入周期
	//分别读入每个周期的人数 
	// T1
	// 入总队 
	// 遍历窗口
	// 有窗空则出队
	// 更新窗口等待时间
	// t++;
	// 更新窗口和队列里的等待时间。
	return 0;
}

//4
//2  5  13  11
//1 3
//2 2 1 3 2
//1 1 1 1 3 3 2 2 1 2 3 1 1
//3 3 2 1 3 1 1 3 1 3 3


//6
//251311159
//1 1 
//1 1 1 1 1 
//1 1 1 1 1 1 1 1 1 1 1 1 1 
//1 1 1 1 1 1 1 1 1 1 1 
//1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
//1 1 1 1 1 1 1 1 1 
//
//1 : 0
//2 : 0
//3 : 0
//4 : 0
//5 : 0
//6 : 1
//7 : 1
//8 : 0
//9 : 1
//10 : 1
//11 : 1
//12 : 1
//13 : 2
//14 : 2
//15 : 2
//16 : 2
//17 : 2
//18 : 3
//19 : 3
//20 : 3
//21 : 2
//22 : 2
//23 : 3
//24 : 3
//25 : 3
//26 : 3
//27 : 4
//28 : 4
//29 : 4
//30 : 4
//31 : 5
//32 : 4
//33 : 4
//34 : 5
//35 : 5
//36 : 5
//37 : 6
//38 : 6
//39 : 6
//40 : 7
//41 : 7
//42 : 7
//43 : 8
//44 : 8
//45 : 8
//46 : 9
//47 : 8
//48 : 8
//49 : 9
//50 : 9
//51 : 9
//52 : 10
//53 : 10
//54 : 10
//55 : 11






```









#### 字符串编辑模拟

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define N 1000
char s[N],sub[N];
char *head,*q,*temp; 
char *out;
int n,a,b,c,i,k;
int t = -1;
struct STK{
	int op;
	int pos;
	char sub[N];
};
char ops[N];
struct STK st[N];
void deletesubstr(char *s,int pos, char *sub){
	int len = strlen(sub);
//	printf("pos %d,to be deleted:%s\n",pos,sub);
//	char *p = s;// head of str 
	char *q = s+pos;// pos of substr
	memmove(q,q+len,strlen(q+len)+1);// '\0'不能漏掉 
//	从q+len的位置开始往q的位置移动字符（q+len，是指针）+1是加一个char的大小。 
//	*(q)
//	return p;
}//
/*
void deletesubstr(char *s,int pos,int n){//从pos 开始 删掉 n个 字符
	int len = strlen(sub);
	char *q = s+pos;// pos of substr
	memmove(q,q+len,strlen(q+len)+1);// '\0'不能漏掉 
	
}*/



char* insert(char *x,char *y,int i){//字符串y 插入到 x 的 第 i位置
	char *temp = (char *)malloc((strlen(y)+100)*sizeof(char)); 
	memset(temp,'\0', sizeof(temp));	
//	printf("success insert\n");
	strncpy(temp,x,i);//从x copy i 个到temp
	temp[strlen(temp)] ='\0';
	strcat(temp,y);
	strcat(temp,x+i);
//	会自动补'\0'
//	s = temp;
	temp[strlen(temp)] ='\0';
	return temp;
}

void operate(){
	if(st[t].op==1){
		char *s = insert(head,st[t].sub,st[t].pos);
		head = s;
//		free(temp);
//		printf("AFTinsert,head:%s\n",head);
	}
	else if(st[t].op==2){
		deletesubstr(head,st[t].pos,ops);
//		head = s;
//		puts(head);
//		printf("AFT:head:%s\n",head);
	}
	else if(st[t].op==3){
		t--;
		if(t>=0){
			if(st[t].op==2){
	//			printf("undo:op2?\n");
				if(st[t].sub[0]!='\0'){
					char* s = insert(head,st[t].sub,st[t].pos);
					head = s; 
//					free(temp);
	//				puts(head);
	//				printf("head:%s\n",head);
				}
			}
			else if (st[t].op==1){
	//			printf("undo:op1\n");
	//			printf("head:%s\n",head);
	//			printf("%s^^^^%s\n",s,st[t].sub);
				deletesubstr(head,st[t].pos,st[t].sub); 
	//			printf("AFT:head:%s\n",head);
	//			head = s;
	//			puts(head);
			}
			t--;
		}
		
	}
	
}
int main(){
//	gets(s);
	fgets(s,N,stdin);
	head = s;
	scanf("%d",&n);
	while(n--){
		t++;
		scanf("%d %d %s",&st[t].op,&st[t].pos,st[t].sub);
		if(t==0&&st[t].op==3){
			t--;
		} 
	}
	while(scanf("%d",&a),a!=-1){
		if(a==2){
			scanf("%d %d",&b,&c);
//			if(b>=strlen(s)) continue;
			t++;
			for(i=b;i<b+c&&s[i]!='\0';i++){
				ops[i-b] = s[i];
			}//ops-需要被删除的子串 
			ops[i-b] = '\0';
			st[t].op = a;
			st[t].pos = b;
//			printf("%s",ops)
			strcpy(st[t].sub,ops);
			operate();
//			puts(s);//采用子串操作 
//			head = s;
//			puts(head);
			memset(ops,0,N);//reset 
 
		}
		else if(a==1){
//			printf("^op1\n"); 
			scanf("%d %s",&b,sub);
			t++;
			st[t].op = a;
			st[t].pos = b;
//			printf("t%d pos%d\n",t,st[t].pos);
			strcpy(st[t].sub,sub);
			operate();
//			head = s;
//			puts(head);
			memset(sub,0,N);	 
		}
		else if(a==3){
				st[++t].op=3;
				operate();
//			head =s;
//			puts(head);
		}
		else if(a==-1)break;		
	}
//	puts(head);
//		printf("LST\n");
		printf("%s",head);
		
		return 0;
//	puts(s);
}






//void assign(int a,int b,char*c){
//	st[t].op = a;
//	st[t].pos = b;
//	strcpy(st[t].sub,c);
//}
//4
//1 20 ainer
//2 0 ???
//1 85 -
//1 99 (LIFO)



```

```c
void insert(int pos, char str[]) {//在pos位置插入字符串str
    strcpy(stack[Top].S, stack[Top-1].S);
    strcpy(stack[Top].S + pos, str);
    strcpy(stack[Top].S + pos + strlen(str), stack[Top-1].S + pos);
}

void delete(int pos, int n){//从pos位置开始删除n个字符
    int len = strlen(stack[Top-1].S);
    if (len-pos<n)//若删除的字符个数多于已有字符个数（即从pos开始的字符个数小于n）
        n = len - pos;//则按实际字符数删除
    strcpy(stack[Top].S, stack[Top-1].S);
    strcpy(stack[Top].S + pos, stack[Top-1].S + pos + n);
    stack[Top].S[len - n] = '\0';
}

void re_insert(int pos, int n) { //即在pos位置删除n个字符（字符串str的长度）
    int len = strlen(stack[Top+1].S);
    strcpy(stack[Top].S, stack[Top+1].S);
    strcpy(stack[Top].S + pos, stack[Top+1].S + pos + n);
    stack[Top].S[len - n] = '\0';
}

void re_delete(int pos, char str[]){//即从pos位置开始插入字符串str
    strcpy(stack[Top].S, stack[Top+1].S);
    strcpy(stack[Top].S + pos, str);
    strcpy(stack[Top].S + pos + strlen(str), stack[Top+1].S + pos);
}


```

```c
int sa[100],sb[100],sc[100];
int ha,hb,hc;
int ta= -1,tb = -1,tc = -1;
int done;
int push_times;
struct Destination{
    char s[20];
    int length;
}d[50];
struct Car{
    int id;
    char s[20];
    int length;
}a[100],b[100],c[100];
int FindMaxB(int tb){
    int h = 0;
    int t = tb;
    int max = -1;
    int idx = -1
    for(i = 0,i<tb;i++){
        if(b[i].length>=max){
            max = length;
            idx = i;
        }
    }
    return idx;
}

void MoveB_A(int x,int tb){// from x to top 
    int count;
	for(count=tb;count>=x;count--){
		a[++ta] = b[tb--];
        push_times++;
    }
    done++;
}
void MoveA_C() {
    while(tb>count){
        c[++tc] = b[tb--];
    }
    
}

void A_B(){// A 全部 到 B
    while(ta!=done-1){
       b[++tb] = a[ta--];
    }// 然后全部放在B
}


int main(){
    char s[20];
    scanf("%d",&n);
    for(i=0;i<n;i++){
        scanf("%s %d",d[i].s,&d[i].length);
    }
    
    scanf("%d",&m);
    while(ta!=m){
        scanf("%d %s",a[++ta].id,s);
        for(j = 0;j<n;j++){
            if(strcmp(s,d[j].s)==0){
       			a[ta].length = d[j].length;
                strcpy(a[ta].s,d[j].s);
                break;
            }
        }
    }// 首先全部放入a;
    A_B();
   /*
    while(ta!=-1){
       b[++tb] = a[ta--];
    }// 然后全部放在B
    */
    
    while(done!=m){
        int idx_max_in_b = FindMaxB(tb);
        MoveB_A(idx_max_in_b,tb);
        c[++tc] = a[ta--];
        A_B();
        a[++ta] = c[tc--];
    }
    
    printf("%d",push_times);
    
    
    
    
}


```

#### 火车调度问题

```c
#include<stdio.h>
#include<string.h>
int sa[100],sb[100],sc[100];
int ha,hb,hc;
int ta= -1,tb = -1,tc = -1;
int done;
int push_times = 0;
struct Destination{
    char s[20];
    int length;
}d[50];
struct Car{
    int id;
    char s[20];
    int length;
}a[100],b[100],c[100];
int FindMaxB(){
	int i;
    int t = tb;
    int max = -1;
    int idx = -1;
    for(i = 0;i<=tb;i++){
        if(b[i].length>=max){
            max = b[i].length;
            idx = i;
        }
    }
    return idx;
}

void MoveB_A(int x){// from x to top 
    int count;
	for(count=tb;count>=x;count--){
		a[++ta] = b[tb--];
        push_times++;
    }
}
//void MoveA_C() {
//    while(tb>count){
//        c[++tc] = b[tb--];
//    }
//    
//}

void A_B(){// A 全部 到 B
    while(ta!=done-1){
       b[++tb] = a[ta--];
    }// 然后全部放在B
}


int main(){
    char s[20];
    int m,n,i,j;
    scanf("%d",&n);
    for(i=0;i<n;i++){
        scanf("%s %d",d[i].s,&d[i].length);
    }
    scanf("%d",&m);
    while(ta!=m-1){
        scanf("%d %s",&a[++ta].id,s);
        for(j = 0;j<n;j++){
            if(strcmp(s,d[j].s)==0){
       			a[ta].length = d[j].length;
                strcpy(a[ta].s,d[j].s);
                break;
            }
        }
    }// 首先全部放入a;
//    for(i=0;i<=ta;i++){
//    	printf("%d %s\n",a[i].id,a[i].s);
//	}
//	printf("\n");
    A_B();
//     for(i=0;i<=tb;i++){
//    	printf("%d ",b[i].id);
//	}
//		printf("\n");
   
   /*
    while(ta!=-1){
       b[++tb] = a[ta--];
    }// 然后全部放在B
    */
    
    while(done!=m){
        int idx_max_in_b = FindMaxB();
        MoveB_A(idx_max_in_b);
       	if(ta!=done){
	        c[++tc] = a[ta--];
	//        printf("c :%d %s\n",c[tc].id,c[tc].s);
	        A_B();
	        a[++ta] = c[tc--];
	        push_times++;
    	}
		done++;
    }
    
    for(i=0;i<=ta;i++){
    	printf("%04d ",a[i].id);
	}
		printf("\n");
   
    printf("%d",push_times);
}

//10
//shijiazhuang 280
//xingtai 390
//xinxiang 610
//zhengzhou 689
//wuchang 1221
//chibi 1339
//yueyang 1434
//changsha 1559
//shaoguan 2057
//guangzhou 2273
//12
//0039 guangzhou
//5217 xingtai
//0262 yueyang
//7205 wuchang
//3211 guangzhou
//4893 shijiazhuang
//2283 shaoguan
//0890 guangzhou
//8729 wuchang
//6839 shijiazhuang
//2122 changsha
//3280 wuchang


```



#### 第五次作业 树

##### 5.1 树叶节点遍历（树-基础题）

【问题描述】

从标准输入中输入一组整数，在输入过程中按照左子结点值小于根结点值、右子结点值大于等于根结点值的方式构造一棵[二叉查找树](https://so.csdn.net/so/search?q=二叉查找树&spm=1001.2101.3001.7020)，然后从左至右输出所有树中叶结点的值及高度（根结点的高度为1）。例如，若按照以下顺序输入一组整数：50、38、30、64、58、40、10、73、70、50、60、100、35，则生成下面的二叉查找树：

![img](20210524222959773.png)

从左到右的叶子结点包括：10、35、40、50、60、70、100，叶结点40的高度为3，其它叶结点的高度都为4。

【输入形式】

先从标准输入读取整数的个数，然后从下一行开始输入各个整数，整数之间以一个空格分隔。

【输出形式】

按照从左到右的顺序分行输出叶结点的值及高度，值和高度之间以一个空格分隔。

【样例输入】

13
50 38 30 64 58 40 10 73 70 50 60 100 35

【样例输出】

10 4
35 4
40 3
50 4
60 4
70 4
100 4

【样例说明】

按照从左到右的顺序输出叶结点（即没有子树的结点）的值和高度，每行输出一个。

```c
#include<stdio.h>
#include<stdlib.h>
struct Node{
	int data;
	int h;
	struct Node * left;
	struct Node * right;
};
typedef struct Node* PNode;
int a[1002];
PNode root = NULL;
PNode insertData(int x , struct Node* root	,int height);
void inorder(PNode t){
	if(t!=NULL){
		inorder(t->left);
		printf("%d %d\n",t->data,t->h);
		inorder(t->right);
	}
}
int main(){
	int n,i,j,k,x;
	scanf("%d",&n);
	for(i=0;i<n;i++){
		scanf("%d",&x);
		root = insertData(x,root,1);
	}
//	inorder(root);
	findleaf(root);
} 
void findleaf(struct Node* node){
	if(!(node->left==NULL&&node->right==NULL)){
		if(node->left!=NULL){
		findleaf(node->left);
		}
		if(node->right!=NULL){
		findleaf(node->right);
		}
	}
	else if(node->left==NULL&&node->right==NULL){
		printf("%d %d\n",node->data,node->h);
	}
}

PNode insertData(int x , PNode root,int height){
	if(root==NULL){
		root = (PNode)malloc(sizeof(struct Node));
		root->data = x;
		root->h = height;
        retrun root;
	}//如果，root是空的，则直接建立一个结点
	else if(x<root->data){
		height++;
		if(root->left==NULL){
			root->left=insertData(x,root->left,height);//空，直接建立
		}
		else{
			insertData(x,root->left,height);//否则继续向下找
		}
	}
	else if(x>=root->data){
		height++;
		if(root->right==NULL){
			
			root->right=insertData(x,root->right,height);
		}
		else 
		{
			insertData(x,root->right,height);
		}
	}
	return root;
}

```





##### 5.2 词频统计（树实现）

【问题描述】

编写程序统计一个英文文本文件中每个单词的出现次数（词频统计），并将统计结果按单词字典序输出到屏幕上。

要求：程序应用二叉排序树（BST）来存储和统计读入的单词。

注：在此单词为仅由字母组成的字符序列。包含大写字母的单词应将大写字母转换为小写字母后统计。在生成二叉排序树不做平衡处理。

【输入形式】

打开当前目录下文件article.txt，从中读取英文单词进行词频统计。

【输出形式】

程序应首先输出二叉排序树中根节点、根节点的右节点及根节点的右节点的右节点上的单词（即root、root->right、root->right->right节点上的单词），单词中间有一个空格分隔，最后一个单词后没有空格，直接为回车（若单词个数不足三个，则按实际数目输出）。

程序将单词统计结果按单词字典序输出到屏幕上，每行输出一个单词及其出现次数，单词和其出现次数间由一个空格分隔，出现次数后无空格，直接为回车。

【样例输入】

当前目录下文件article.txt内容如下：
“Do not take to heart every thing you hear.”
“Do not spend all that you have.”
“Do not sleep as long as you want;”

【样例输出】

do not take
all 1
as 2
do 3
every 1
have 1
hear 1
heart 1
long 1
not 3
sleep 1
spend 1
take 1
that 1
thing 1
to 1
want 1
you 3

【样例说明】

程序首先在屏幕上输出程序中二叉排序树上根节点、根节点的右子节点及根节点的右子节点的右子节点上的单词，分别为do not take，然后按单词字典序依次输出单词及其出现次数。

```c
#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<string.h>
#define maxline 1000
struct Node{
	char word[maxline];
	int cnt;
	struct Node * left;
	struct Node * right;
};
typedef struct Node* PNode;
void inorder(struct Node* node);
void findleaf(struct Node* node);
//void insert(int x,struct Node* root);
void insert(int x,struct Node** node);
void insertword(char* s,struct Node** node);
int getword(FILE *in,char *w);
char word[maxline];
PNode root = NULL;
int main(){
	int n,i,j,k,x;
	FILE *in;
	in = fopen("article.txt","r");
	while(getword(in,word)!=-1){
//		printf("%s\n",word);
		insertword(word,&root);
	} 
	if(root!=NULL){
		if(root->right!=NULL){
			printf("%s ",root->word);
			if(root->right->right!=NULL){
				printf("%s ",root->right->word);
				printf("%s\n",root->right->right->word);
			} 
			else{
				printf("%s\n",root->right->word);
			}
		}
		else{
			printf("%s\n",root->word);
		}
	}
	
	inorder(root);	
}

void inorder(struct Node* node){
	if(node!=NULL){
		inorder(node->left);
		printf("%s %d\n",node->word,node->cnt);
		inorder(node->right);
	}
}

int getword(FILE *in,char *w){
	int c;
	while((isalpha(c = fgetc(in)))==0){
		if(c==EOF) return -1;
		else continue;
	}
	do{
		*w = tolower(c);
		w++;	
	}while(isalpha(c = fgetc(in)));
	*w = '\0';
	return 0;
}
PNode insertword(char *s,struct Node * root){
   	 	PNode p;
		p = (PNode)malloc(sizeof(struct Node));
		strcpy(p->word,s);
		p->cnt = 1;
		p->left =NULL;
		p->right = NULL;
		if((root)==NULL){
//			printf("sucs");
            (root) = p;
            return root;
		}
		else{	
			PNode tmp;
			tmp = root;
			while(tmp!=NULL){
				if(strcmp(s,tmp->word)>0){
					if(tmp->right==NULL){
						tmp-> right = p;
						tmp = NULL;
					}
					else{
						tmp = tmp->right;
					}
				}
				else if(strcmp(s,tmp->word)<0){
					if(tmp->left==NULL){
						tmp->left = p;
						tmp =NULL;
					}
					else{
						tmp = tmp->left;
					}
				}
				else if(strcmp(s,tmp->word)==0){
					(tmp->cnt)++;
					tmp = NULL;
				}
			}
		}
    return root
}
//
void insertword(char* s,struct Node** root){
		PNode p;
		p = (PNode)malloc(sizeof(struct Node));
		strcpy(p->word,s);
		p->cnt = 1;
		p->left =NULL;
		p->right = NULL;
		if((*root)==NULL){
//			printf("sucs");
			(*root) = p;
//			printf("%d ",root->data);
//			printf("aft insert %d\n",root==NULL);
		}
		else{	
//		printf("new");
			PNode tmp;
			tmp = *root;
			while(tmp!=NULL){
				if(strcmp(s,tmp->word)>0){
					if(tmp->right==NULL){
						tmp-> right = p;
						tmp = NULL;
					}
					else{
						tmp = tmp->right;
					}
				}
				else if(strcmp(s,tmp->word)<0){
					if(tmp->left==NULL){
						tmp->left = p;
						tmp =NULL;
					}
					else{
						tmp = tmp->left;
					}
				}
				else if(strcmp(s,tmp->word)==0){
//					printf("findequ\n");
					(tmp->cnt)++;
					tmp = NULL;
				}
			}
		}
	
}







//13
//50 38 30 64 58 40 10 73 70 50 60 100 35

```

######  注意insertword的两种实现





##### 5.3 计算器（表达式计算-表达式树实现）

【问题描述】

从标准输入中读入一个整数算术运算表达式，如24 / ( 1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2 )= ，计算表达式结果，并输出。

要求：

1. 表达式运算符只有+、-、*、/，表达式末尾的=字符表示表达式输入结束，表达式中可能会出现空格；
2. 表达式中会出现圆括号，括号可能嵌套，不会出现错误的表达式；
3. 出现除号/时，以整数相除进行运算，结果仍为整数，例如：5/3结果应为1。
4. 要求采用表达式树来实现表达式计算。

表达式树（expression tree）：

我们已经知道了在计算机中用后缀表达式和栈来计算中缀表达式的值。在计算机中还有一种方式是利用表达式树来计算表达式的值。表达式树是这样一种树，其根节点为操作符，非根节点为操作数，对其进行后序遍历将计算表达式的值。由后缀表达式生成表达式树的方法如下：

- 读入一个符号：
- 如果是操作数，则建立一个单节点树并将指向他的指针推入栈中；
- 如果是运算符，就从栈中弹出指向两棵树T1和T2的指针（T1先弹出）并形成一棵新树，树根为该运算符，它的左、右子树分别指向T2和T1，然后将新树的指针压入栈中。



#### 前缀中缀后缀相互转换

- 中缀转后缀：
  - 从前往后遍历中缀表达式
    - 遇到数字直接输出，遇到操作符入栈/..
  - 利用表达式树
  - ![image-20230617172958266](image-20230617172958266.png)

中缀转前缀：

- 从后往前遍历中缀表达式
  - 遇到数字直接输出，遇到操作符入栈/..
- 利用表达式树





例如输入的后缀表达为：

ab+cde+**

则生成的表达式树为：

![img](2021052421555686.png)

【输入形式】

从键盘输入一个以=结尾的整数算术运算表达式。操作符和操作数之间可以有空格分隔。

【输出形式】

首先在屏幕上输出表达式树根、左子节点及右子节点上的运算符或操作数，中间由一个空格分隔，最后有一个回车（如果无某节点，则该项不输出）。然后输出表达式计算结果。

【样例输入】

24 / ( 1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2 ) =

【样例输出】

\* / /
18

【样例说明】

按照运算符及括号优先级依次计算表达式的值。在生成的表达树中，*是根节点的运算符，/ 是根节点的左子节点上运算符，/是根节点的右子节点上运算符，按题目要求要输出。

![image-20230617171100063](image-20230617171100063.png)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#define N 500010
int num[N];
char s[N];
char op[N];
int i,j,t_num=-1,t_s=-1,t_op=-1;
int priority[256];
int x;
struct Node{
	int type;// 0 num,1 operator.
	char c;
	int val;
	struct Node * left;
	struct Node * right;
};
typedef struct Node newnode;
typedef struct Node* PNode;
int nodecnt = 0;
newnode Nodelist[1000];
newnode p_num,p_char;
PNode Exptree[1000],root;
int expcnt;
void infix_to_postfix(char s[]);
void eval();
void e_value();
void postfixeval(struct Node Nodelist[]);
void postfix_to_expressiontree(newnode Nodelist[]);
int main(){
    priority['+']=1;
    priority['-']=1;
    priority['*']=2;
    priority['/']=2;
	gets(s);
	infix_to_postfix(s);
	postfix_to_expressiontree(Nodelist);

//	if(root!=NULL){
		if(root->type==0){
			printf("%d ",root->val);
		}
		else{
			printf("%c ",root->c);		
		}
//	}
//	if(root->left!=NULL){
		if(root->left->type==0){
			printf("%d ",root->left->val);
		}
		else{
			printf("%c ",root->left->c);		
		}
//	}
//	if(root->right!=NULL){
		if(root->right->type==0){
			printf("%d ",root->right->val);
		}
		else{
			printf("%c ",root->right->c);		
		}
	printf("\n");
	t_op=-1,t_num=-1,i=0;
	postfixeval(Nodelist);
//	printf("%.2f",num[t_num]);
}
void e_value(){
	int num2 = num[t_num--];
	int  num1 = num[t_num--];
	char opt = op[t_op--];
//	printf("insert %c\n",opt);
	if(opt=='+') num[++t_num] = num1+ num2;
	else if(opt=='-') num[++t_num] = num1- num2;
	else if(opt=='*') num[++t_num] = num1* num2;
	else if(opt=='/') num[++t_num] = num1/ num2;
	
}
void eval(){
	char opt = op[t_op--];
	p_char.type  = 1;
	p_char.c = opt;
	Nodelist[nodecnt++] = p_char;
}

void infix_to_postfix(char s[]){
	for(int i=0;i<strlen(s);i++){
		if(s[i]==' ')continue;
		else if(s[i]=='=') break;
		else if(isdigit(s[i])){
			x=0,j=i;
			
			p_num.type = 0;
			while(j<strlen(s)&&isdigit(s[j])){
				x = x*10+s[j]-'0';
				j++;
			}
            p_num = (PNode)malloc(sizeof(struct Node));
            
			p_num.val = x;
            p_num->left = NULL;
			p_num->right =NULL;
            Exp[expcnt++] = p_num;
			Nodelist[nodecnt++] = p_num;
			num[++t_num] = x;
			i = j-1;
		}
		else if((s[i]=='(')){
			op[++t_op] = '(';
		}
		else if((s[i]==')')){
			while(op[t_op]!='('){
				eval();
			}
			t_op--;//把'('弹掉
		}
		else{
			while(t_op>-1&&priority[(int)op[t_op]]>=priority[(int)s[i]]) eval();//对比符号栈顶的元素与所获得的符号的优先级，栈内优先级高于栈外优先级
			op[++t_op] =s[i];//如果栈外优先级更高，入栈		
			}
	}
	while(t_op>=0) eval();
}



void postfix_to_expressiontree(newnode Nodelist[]){
	int i;
	PNode p;
	for(i=0;i<nodecnt;i++){
		p = (PNode)malloc(sizeof(struct Node));
		if(Nodelist[i].type==0){
			p->type = 0;
			p->val = Nodelist[i].val;
			p->left = NULL;
			p->right =NULL;
			Exptree[expcnt++] = p;
		}
		else if(Nodelist[i].type==1){
			p->type = 1;
			p->c = Nodelist[i].c;
			PNode q1,q2;
			q1 = Exptree[--expcnt];
			q2 = Exptree[--expcnt];
			p->right=q1;
			p->left = q2;
			Exptree[expcnt++] = p; 
		}
	}
	root = Exptree[0];
} 


void postfixeval(struct Node Nodelist[]){
	t_op = -1;
	t_num = -1;
	priority['+']=1;
    priority['-']=1;
    priority['*']=2;
    priority['/']=2;
//	gets(s);
	for(int i =0;i<nodecnt;i++){
		if(Nodelist[i].type==0){
			num[++t_num] = Nodelist[i].val;
//			printf("insert:%d\n",Nodelist[i].val);
		}
		else if(Nodelist[i].type==1){
			op[++t_op] = Nodelist[i].c;
			e_value();
//			if(Nodelist[i].c=='('){
//				op[++t_op] = '(';
//			}
//			else if(Nodelist[i].c==')'){
//				while(op[t_op] !='('){
//					e_value();
//				}
//				t_op--;
//			}
//			else{
//				while(t_op>-1&&priority[op[t_op]]>=priority[Nodelist[i].c]) e_value();//对比符号栈顶的元素与所获得的符号的优先级，栈内优先级高于栈外优先级
//				op[++t_op] =Nodelist[i].c;//如果栈外优先级更高，入栈		
//			}
		}
	}
	while(t_op>=0) e_value();
	printf("%d",num[0]);
}
//	for(int i=0;i<strlen(s);i++){
//		if(s[i]==' ')continue;
//		else if(s[i]=='=') break;
//		else if(isdigit(s[i])){
//			x=0,j=i;
//			while(j<strlen(s)&&isdigit(s[j])){
//				x = x*10+s[j]-'0';
//				j++;
//			}
//			num[++t_num] = x;
//			i = j-1;
//		}
//		else if((s[i]=='(')){
//			op[++t_op] = '(';
//		}
//		else if((s[i]==')')){
//			while(op[t_op]!='('){
//				eval();
//			}
//			t_op--;//把'('弹掉
//		}
//		else{
//			while(t_op>-1&&priority[(int)op[t_op]]>=priority[(int)s[i]]) eval();//对比符号栈顶的元素与所获得的符号的优先级，栈内优先级高于栈外优先级
//			op[++t_op] =s[i];//如果栈外优先级更高，入栈		
//			}
//	}
//	while(t_op>=0) eval();
//	printf("%.2f",num[t_num]);
//}

//24/(1+5/3+36/6/2-2)*(12/2/2)=
//24/(1+5/3+ 36 /6/2-2)*( 12 / 2 / 2)  =
////9+(3-1)*3+8/2=
//24 / (1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2 )     =
// 1+cde+**
// 样例 2*(9+6/3-5)+4
// 结果 2963/+5-*4+
//注意：遇到数字入栈，遇到运算符根据优先级先入栈再出栈实际上是计算中缀表达式的方法
//计算后缀表达式方法：遇到运算符直接算！ 



```



##### 服务优化

【问题描述】

假设某机场所有登机口（Gate）呈树形排列（树的度为3），安检处为树的根，如下图所示。图中的分叉结点（编号大于等于100）表示分叉路口，登机口用小于100的编号表示（其一定是一个叶结点）。通过对机场所有出发航班的日志分析，得知每个登机口每天的平均发送旅客流量。作为提升机场服务水平的一个措施，在不改变所有航班相对关系的情况下（即：出发时间不变，原在同一登机口的航班不变），仅改变登机口（例如：将3号登机口改到5号登机口的位置），使得整体旅客到登机口的时间有所减少（即：从安检口到登机口所经过的分叉路口最少）。

<img src="1616076254353079599135.jpg" alt="plane.jpg" style="zoom: 50%;" />



编写程序模拟上述登机口的调整，登机口调整规则如下：

1）首先按照由大到小的顺序对输入的登机口流量进行排序，流量相同的按照登机口编号由小到大排序；

2）从上述登机口树的树根开始，将登机口按照从上到下（安检口在最上方）、从左到右的顺序，依次对应上面排序后将要调整的登机口。

例如上图的树中，若只考虑登机口，则从上到下有三层，第一层从左到右的顺序为：5、6、14、13，第二层从左到右的顺序为：7、8、9、10、1、2、18、17、16、15，第三层从左到右的顺序为：11、12、3、4、20、19。若按规则1排序后流量由大至小的前五个登机口为3、12、16、20、15，则将流量最大的3号登机口调整到最上层且最左边的位置（即：5号登机口的位置），12号调整到6号，16号调整到14号，20号调整到13号，15号调整到第二层最左边的位置（即7号登机口的位置）。

【输入形式】

1）首先按层次从根开始依次输入树结点之间的关系。其中分叉结点编号从数字100开始（树根结点编号为100，其它分叉结点编号没有规律但不会重复），登机口为编号小于100的数字（编号没有规律但不会重复，其一定是一个叶结点）。树中结点间关系用下面方式描述：

R S1 S2 S3 -1

其中R为分叉结点，**从左至右**S1，S2，S3分别为树叉R的子结点，其可为树叉或登机口，由于树的度为3，S1，S2，S3中至多可以2个为空，最后该行以-1和换行符结束。各项间以一个空格分隔。如：

100 101 102 103 -1

表明编号100的树根有三个子叉，编号分别为101、102和103，又如：

104 7 8 -1 

表明树叉104上有2个编号分别为7和8的登机口。

假设分叉结点数不超过100个。分叉结点输入的顺序不确定，但可以确定：输入某个分叉结点信息时，其父结点的信息已经输入。

输入完所有树结点关系后，在新的一行上输入-1表示树结点关系输入完毕。

2）接下来输入登机口的流量信息，每个登机口流量信息分占一行，分别包括登机口编号（1~99之间的整数）和流量（大于0的整数），两整数间以一个空格分隔。登机口数目与前面构造树时的登机机口数目一致。

【输出形式】

按照上述调整规则中排序后的顺序（即按旅客流量由大到小，流量相同的按照登机口编号由小到大）依次分行输出每个登机口的调整结果：先输出调整前的登机口编号，然后输出字符串"->"（由英文减号字符与英文大于字符组成），再输出要调整到的登机口编号。

【样例输入】



100 101 102 103 -1

103 14 108 13 -1

101 5 104 6 -1

104 7 8 -1

102 105 106 107 -1

106 1 110 2 -1

108 16 15 -1

107 18 111 17 -1

110 3 4 -1

105 9 109 10 -1

111 20 19 -1

109 11 12 -1

-1

17 865

5 668

20 3000

13 1020

11 980

8 2202

15 1897

6 1001

14 922

7 2178

19 2189

1 1267

12 3281

2 980

18 1020

10 980

3 1876

9 1197

16 980

4 576

【样例输出】



12->5

20->6

8->14

19->13

7->7

15->8

3->9

1->10

9->1

13->2

18->18

6->17

2->16

10->15

11->11

16->12

14->3

17->4

5->20

4->19

【样例说明】

样例输入了12条树结点关系，形成了如上图的树。然后输入了20个登机口的流量，将这20个登机口按照上述调整规则1排序后形成的顺序为：12、20、8、19、7、15、3、1、9、13、18、6、2、10、11、16、14、17、5、4。最后按该顺序将所有登机口按照上述调整规则2进行调整，输出调整结果。
【评分标准】

该题要求计算并输出登机口的调整方法，提交程序名为adjust.c。

```c
#include<stdio.h>
#include<stdlib.h>

struct Node{
	int flux;
	int idx;
	struct Node* left;
	struct Node* mid;
	struct Node* right;
	struct Node* next;
};
typedef struct Node newnode;
typedef struct Node* PNode;
int nodecnt = 0;
newnode Nodelist[1000];
//newnode p_num,p_char;
PNode Exptree[1000],root=NULL;
char huffcodetable[200][128];
void preorder(PNode node);
PNode Node_search(int x, PNode root);
//PNode root = NULL;
PNode p,q;
int totalnum;
int idx_arr[100],idx_cnt=0,layer_cnt=0;
struct Node* layerorder_arr[100];
void  layerorder(PNode root);

int cmp(const void*a,const void*b);
int main(){
	int b,a[1000],cnt,i,j,num;
	while(scanf("%d",&b),b!=-1){//读入结点
		if(root==NULL){
			p = (PNode)malloc(sizeof(struct Node));
//			printf("b:%d ",b);
			p->idx = b;
			q = root = p;
			nodecnt++;
//			printf("root:%d ",root->idx);
		}
		else{	
	//		printf("root:%d",root->idx);
//			printf("to find %d",b);
			q = Node_search(b,root);
            // 找到点q
			if(q==NULL){
//				printf("not found\n");
			}
			else;
//			printf("b:%d,q:%d\n",b,q->idx);
		}
		while(scanf("%d",&a[cnt]),a[cnt]!=-1){// 读入结点的树枝
			if(a[cnt]<100) totalnum++;
				p = (PNode)malloc(sizeof(struct Node));
				p->idx = a[cnt];
				if(cnt==0){
					q->left=p;
//					printf("%d ",p->idx);
				}
				else if(cnt==1){
					q->mid = p;
//					printf("%d ",p->idx);
				}
				else if(cnt==2){
					q->right = p;
//					printf("%d ",p->idx);
				}
				cnt++;
//				printf("root:%d ",root->idx);
		}
//	printf("root:%d",root->idx);
//	printf("root:%d",q->idx);
//		for(i=0;i<cnt;i++){
//			printf("%d ",a[i]);
//		} 
		cnt = 0;
//		printf("\n");		
	}
	for(i=0;i<totalnum;i++){
		scanf("%d %d",&b,&num);
		q = Node_search(b,root);
		q->flux = num;
		q = NULL;
	}
//	printf("end\n");
	if(root!=NULL)
	layerorder(root);
//	printf("layerorder ended\n");
//	for(i=0;i<totalnum;i++){
//		printf("idx:%d-flux:%d\n",layerorder_arr[i]->idx,layerorder_arr[i]->flux);
//	}
	qsort(layerorder_arr,totalnum,sizeof(struct Node*),cmp);
//	for(i=0;i<totalnum;i++){
//		printf("idx:%d-flux:%d\n",layerorder_arr[i]->idx,layerorder_arr[i]->flux);
//	}
	for(i=0;i<totalnum;i++){
		printf("%d->%d\n",layerorder_arr[i]->idx,idx_arr[i]);
	}
//	preorder(root);
}



PNode Node_search(int x, PNode root){
	PNode t;
	t = root;
	if(t!=NULL){
		if(t->idx ==x){
			return t;
		}
		else{
			PNode tt = Node_search(x,t->left);
			if(tt==NULL){
				PNode tt = Node_search(x,t->mid);
				if(tt==NULL)	
				{
					PNode tt = Node_search(x,t->right);
				}
				else{
					return tt;
				}
			}
			else{
				return tt;
			}
		}
	}
	else return NULL;
	}
//Node*  searchBST(Node* t,int key)
//{//在 (root==t) 的子树里找 key
//      Node*  p=t;
//      while(p!=NULL){
//             if(key == p->data)  
//                  return p;       /* 查找成功 */
//             if(key > p->data)
//                  p=p->rchild; /* 将p移到右子树的根结点 */
//             else
//                  p=p->lchild; /* 将p移到左子树的根结点 */
//       }//循环找就行了
//       return NULL; /* 查找失败 */
//}


void preorder(PNode node){
    //
	if(node!=NULL){
		printf("%d\n",node->idx);
		preorder(node->left);
		preorder(node->mid);
		preorder(node->right);
    }
}
void  layerorder(PNode root){
      PNode queue[100010];
	  struct Node* p;
      int h=0, t=-1;
      if(root!=NULL){
           queue[++t]=root;   
//          t=-1;     
//          h =0;
           while(h<=t){                      //若队列不空 
                 p=queue[h++];//出队  
                 if(p->idx<100){
                 	idx_arr[idx_cnt++] = p->idx;//表示层序遍历登机口的顺序
					layerorder_arr[layer_cnt++] = p;//稍后需要对其按照流量大小进行排序 
//                 	printf("id:%d,flux:%d\n",p->idx,p->flux);
				 }                    //访问p指结点
                 if(p->left!=NULL)           // 若左孩子非空 
                        queue[++t]=p->left;
                 if(p->mid!=NULL){
                 	queue[++t] = p->mid;
				 } 
				 if(p->right!=NULL)           //若右孩子非空 
                        queue[++t]=p->right;
           }
      }
}
int cmp(const void*a,const void*b){
	struct Node** x = (struct Node**)a;
	struct Node** y = (struct Node**)b;
	//注意列表里的元素是一级指针，qsort，cmp函数内对其调用则是二级指针
	//二级指针的取值就是一级指针的地址。 
	if((*x)->flux<(*y)->flux) return 1;
	else if((*x)->flux>(*y)->flux) return -1;
	else return ((*x)->idx>(*y)->idx);
}


//100 101 102 103 -1
//103 14 108 13 -1
//101 5 104 6 -1
//104 7 8 -1
//102 105 106 107 -1
//106 1 110 2 -1
//108 16 15 -1
//107 18 111 17 -1
//110 3 4 -1
//105 9 109 10 -1
//111 20 19 -1
//109 11 12 -1
//-1
//17 865
//5 668
//20 3000
//13 1020
//11 980
//8 2202
//15 1897
//6 1001
//14 922
//7 2178
//19 2189
//1 1267
//12 3281
//2 980
//18 1020
//10 980
//3 1876
//9 1197
//16 980
//4 576


```





#### 2018 final

##### 网络打印机

【问题描述】

某单位信息网络结构呈树型结构，网络中节点可为交换机、计算机和打印机三种设备，计算机和打印机只能位于树的叶节点上。如要从一台计算机上打印文档，请为它选择最近（即经过交换机最少）的打印机。

在该网络结构中，根交换机编号为0，其它设备编号可为任意有效正整数，每个交换机有8个端口（编号0-7）。当存在多个满足条件的打印机时，选择按树前序遍历序排在前面的打印机。

![img](20210524221952313.png)

【输入形式】

首先从标准输入中输入两个整数，第一个整数表示当前网络中设备数目，第二个整数表示需要打印文档的计算机编号。两整数间以一个空格分隔。假设设备总数目不会超过300。

然后从当前目录下的in.txt读入相应设备配置表，该表每一行构成一个设备的属性，格式如下：

<设备ID> <类型> <设备父节点ID> <端口号>

<设备ID>为一个非负整数，表示设备编号；<类型>分为：0表示交换机、1表示计算机、2表示打印机；<设备父结点ID>为相应结点父结点编号，为一个有效非负整数；<端口号>为相应设备在父结点交换机中所处的端口编号，分别为0-7。由于设备配置表是按设备加入网络时的次序编排的，因此，表中第一行一定为根交换机（其属性为0 0 -1 -1）；其它每个设备结点一定在其父设备结点之后输入。每行中设备属性间由一个空格分隔，最后一个属性后有换行符。

【输出形式】

向控制台输出所选择的打印机编号，及所经过的交换机的编号，顺序是从需要打印文档的计算机开始，编号间以一个空格分隔。

【样例输入】

37 19

in.txt中的信息如下：

0 0 -1 -1
1 0 0 0
2 0 1 2
3 1 1 5
4 0 0 1
5 1 4 0
6 2 2 2
7 0 4 2
8 0 0 4
9 0 2 0
10 0 9 0
11 2 10 3
12 0 9 2
13 0 7 0
14 0 13 0
15 2 7 3
16 0 8 1
17 0 16 0
18 1 17 5
19 1 9 5
20 0 12 1
21 1 14 1
22 1 14 2
23 1 13 2
24 1 12 5
25 0 20 1
26 1 20 2
27 0 14 7
28 0 16 1
29 1 4 3
30 0 16 7
31 0 28 0
32 2 31 0
33 1 30 2
34 1 31 2
35 0 31 5
36 1 35 3

【样例输出】

11 9 10

【样例说明】

样例输入中37表示当前网络共有37台设备，19表示编号为19的计算机要打印文档。in.txt设备表中第一行0 0 -1 -1表示根节点交换机设备，其设备编号为0 、设备类型为0（交换机）、父结点设备编号-1表示无父设备、端口-1表示无接入端口；设备表第二行1 0 0 0表示设备编号为1 、设备类型为0（交换机）、父结点设备编号0（根交换机）、端口0表示接入父结点端口0；设备表中行5 1 4 0表示设备编号为5 、设备类型为1（计算机）、父结点设备编号4、端口0表示接入4号交换机端口0；设备表中行6 2 2 2表示设备编号为6 、设备类型为2（打印机）、父结点设备编号2、端口2表示接入2号交换机端口2。

样例输出11 9 10表示选择设备编号为11的打印机打印文档，打印需要经过9号和10号交换机（尽管6号和11号打印机离19号计算机距离相同，但11号打印机按树前序遍历时排在6号之前）。

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define maxn 8
#define max_size 10100
typedef struct tree_node{
    int no;
    int type;
    int father_no;
    int deep;
    struct tree_node *child[maxn];
    struct tree_node *father_pos;
}node,*tree_ptr;
tree_ptr root=NULL;

tree_ptr create_node(int no,int type,int father,int deep,tree_ptr pa);
tree_ptr add(int no,int type,int father,int fa_pos);
tree_ptr find_father(int father);

tree_ptr queue[max_size];
int front,rear,count;
void init_queue();
int is_empty();
void enqueue(tree_ptr temp);
tree_ptr dequeue();

void pre_order();
tree_ptr pre_stack[max_size];
int pos_stack;
void push(tree_ptr temp);
tree_ptr pop();
int is_stack_empty();

void visit_computer_to_root(tree_ptr computer_num);
tree_ptr LCA(tree_ptr switch_num);
int visit[max_size];

tree_ptr switches[max_size];
int switch_len=0;
tree_ptr find_is_ans(tree_ptr elder,tree_ptr now);
void print_result(tree_ptr goal,tree_ptr min_switch,tree_ptr min_LCA_node);

int main()
{
    int sum,need;
    scanf("%d%d",&sum,&need);
    FILE *in;
    in=fopen("in.txt","r");
    
    int no,type,father,fa_pos;
    tree_ptr goal=NULL;
    for(int i=0;i<sum;i++){
        fscanf(in,"%d %d %d %d",&no,&type,&father,&fa_pos);
        if(no==need){
            goal=add(no,type,father,fa_pos);
        }
        else if(type==2){
            switches[switch_len++]=add(no,type,father,fa_pos);
        }
        else{
            add(no,type,father,fa_pos);
        }
    }
    int min=0x3f3f3f3f;
    tree_ptr min_switch=NULL;
    tree_ptr min_LCA_node=NULL;
    /*
    printf("%d\n",switch_len);
    for(int i=0;i<switch_len;i++){
        printf("%d %d\n",switches[i]->no,switches[i]->deep);
    }
    */
    visit_computer_to_root(goal);
    for(int i=0;i<switch_len;i++){
        //printf("main:%d %d\n",switches[i]->no,switches[i]->deep);
        tree_ptr LCA_node=LCA(switches[i]);
        if(LCA_node==NULL) continue;
        int dist=goal->deep+switches[i]->deep-2*LCA_node->deep;
        if(dist<min){
            min_LCA_node=LCA_node;
            min_switch=switches[i];
            min=dist;
        }
        if(dist==min){
            min_LCA_node=LCA_node;
            min_switch=find_is_ans(min_switch,switches[i]);
            min=dist;
        }
        //printf("min:%d\n",min);
    }
    //printf("%d %d %d\n",min_switch->no,min_switch->type,min_switch->deep);
    print_result(goal,min_switch,min_LCA_node);
    //pre_order();
    fclose(in);
    return 0;
}

tree_ptr create_node(int no,int type,int father,int deep,tree_ptr pa)
{
    tree_ptr temp=(tree_ptr)malloc(sizeof(node));
    temp->father_no=father;
    temp->type=type;
    temp->no=no;
    temp->deep=deep;
    temp->father_pos=pa;
    for(int i=0;i<8;i++){
        temp->child[i]=NULL;
    }
    //printf("%d\n",temp->no);
    return temp;
}

tree_ptr add(int no,int type,int father,int fa_pos)
{
    if(root==NULL){
        root=create_node(no,type,father,1,NULL);
        return root;
    }else{
        tree_ptr pa=find_father(father);
        tree_ptr now=create_node(no,type,father,pa->deep+1,pa);
        pa->child[fa_pos]=now;
        //printf("%d %d\n",pa->no,now->no);
        return now;
    }
}

tree_ptr find_father(int father)
{
    init_queue();
    enqueue(root);
    while(!is_empty()){
        tree_ptr temp=dequeue();
        //printf("%d\n",temp->no);
        if(temp->no==father) {
            return temp;
        }
        else{
            for(int i=0;i<8;i++){
                if(temp->child[i]){
                    enqueue(temp->child[i]);
                }
            }
        }
    }
    return NULL;
}

void init_queue()
{
    for(int i=0;i<max_size;i++){
        queue[i]=NULL;
    }
    front=0;
    rear=max_size-1;
    count=0;
}

int is_empty()
{
    return count==0;
}

void enqueue(tree_ptr temp)
{
    rear=(rear+1)%max_size;
    queue[rear]=temp;
    count++;
}

tree_ptr dequeue()
{
    tree_ptr temp;
    temp=queue[front];
    count--;
    front=(front+1)%max_size;
    return temp;
}

void pre_order()
{
    pos_stack=-1;
    memset(pre_stack,'\0',sizeof(pre_stack));
    push(root);
    while(!is_stack_empty()){
        tree_ptr temp=pop();
        printf("%d %d %d\n",temp->no,temp->type,temp->deep);
        for(int i=7;i>=0;i--){
            if(temp->child[i]){
                push(temp->child[i]);
            }
        }
    }
}

void push(tree_ptr temp)
{
    pre_stack[++pos_stack]=temp;
}

tree_ptr pop()
{
    tree_ptr temp=pre_stack[pos_stack];
    pos_stack--;
    return temp;
}

int is_stack_empty()
{
    return pos_stack==-1?1:0;
}

void visit_computer_to_root(tree_ptr computer_num)
{
    tree_ptr switches_temp[max_size];
    for(int i=0;i<switch_len;i++){
        switches_temp[i]=switches[i];
    }
    memset(visit,0,sizeof(visit));
    tree_ptr temp=computer_num;
    while(temp!=NULL){
        visit[temp->no]=1;
        //printf("%d\n",temp->no);
        temp=temp->father_pos;
    }
    for(int i=0;i<switch_len;i++){
        switches[i]=switches_temp[i];
    }
}

tree_ptr LCA(tree_ptr switch_num)
{
    tree_ptr temp1=NULL;
    temp1=switch_num;
    //printf("%d %d %d\n",temp1->no,temp1->father_no,temp1->deep);
    while(temp1!=NULL){
        if(visit[temp1->no]==1){
            //printf("res:%d %d\n",temp1->no,temp1->deep);
            return temp1;
        }
        temp1=find_father(temp1->father_no);
        //printf("father:%d %d\n",temp1->no,temp1->deep);
    }
    return NULL;
}

tree_ptr find_is_ans(tree_ptr elder,tree_ptr now)
{
    pos_stack=-1;
    for(int i=0;i<max_size;i++){
        pre_stack[i]=NULL;
    }
    push(root);
    while(!is_stack_empty()){
        tree_ptr temp=pop();
        if(temp->no==elder->no) return elder;
        if(temp->no==now->no) return now;
        for(int i=7;i>=0;i--){
            if(temp->child[i]){
                push(temp->child[i]);
            }
        }
    }
}

void print_result(tree_ptr goal,tree_ptr min_switch,tree_ptr min_LCA_node)
{
    printf("%d",min_switch->no);
    tree_ptr temp=goal;
    while (temp!=min_LCA_node){
        printf(" ");
        temp=temp->father_pos;
        printf("%d",temp->no);
    }
    temp=min_switch;
    tree_ptr stack[max_size];
    for(int i=0;i<max_size;i++){
        stack[i]=NULL;
    }
    int pos_res_stack=-1;
    while(temp!=min_LCA_node){
        temp=temp->father_pos;
        stack[++pos_res_stack]=temp;
    }
    pos_res_stack--;//刨除公共祖先
    while(pos_res_stack!=-1){
        printf(" %d",stack[pos_res_stack]->no);
        pos_res_stack--;
    }
}

```



#### 2019final

afile[ , , , , ,, ,,,];

依次读入,直接通过parent建树。

现在得到了一个存放在数组里的树,

对根节点进行dfs，把找到的都放进result里面





##### 寻找同名文件-祖先问题



```c



```

```c

scanf("%s",s);
while(c!='\0'){
	int a = getnum;
	if(c=='('){
		
	}
	


}


for(int i=0;i<strlen(s);i++){
		if(isdigit(s[i])){
			int x=0,j=i;
			while(j<strlen(s)&&isdigit(s[j])){
				x = x*10+s[j]-'0';
				j++;
			}
			num[++t_num] = x;
			i = j-1;
		}//首先，获取数字和字符
		else if((s[i]=='(')){
			op[++t_op] = '(';
		}//遇到左括号，入栈
		else if((s[i]==')')){
			while(op[t_op]!='('){
				eval();
			}//遇到右括号，只要没遇到左括号，就把op栈里面的弹出**直接**运算
			t_op--;//最后把'('弹掉
		}
		else{
			while(t_op>-1&&priority[(int)op[t_op]]>=priority[(int)s[i]]) eval();//对比符号栈顶的元素与所获得的符号的优先级，栈内优先级高于栈外优先级
			op[++t_op] =s[i];//如果栈外优先级更高，入栈		
			}
	}

struct Node{
	int type;
    char time[30];
    char name[20];
    int flag;
    struct File* next[MAX];
    struct File* parent
}file[1000];
int layer = 0;
int temp = 0;
scanf("%d%s",&root,s);
char *c = s;
for(i=0;i<strlen(c);i++){
	if(c[i]=='('){
        layer++;
    }
    else if(c[i]==')'){
        layer--;
    }
    if(isdigit(s[i])){
			int x=0,j=i;
			while(j<strlen(s)&&isdigit(s[j])){
				x = x*10+s[j]-'0';
				j++;
			}
        	int number = x;
			i = j-1;	
        file[root].next[file[root].flag++] = number;        	
		file[number].layer  =layer;
    }//首先，获取数字和字符
    
    



}



}

```





```c
#include<stdio.h>
#include<stdlib.h>
#inlcude<string.h>

#define MAX
typedef struct File{
	int time,type;
    char name[20];
    int flag ;
    struct File* link[MAX];
    struct File* parent
}afile;
afile* root,file[10000] = {}
char target[20];
typedef struct rtype{
    afile* result;
    int deep;
}result;
result results[1234];
int main(){
    FILE* fpr = fopen("files.txt","r");
    int i,j,n;
    char fname[20];
    scanf("%s%d",target,&n);
    for(i=0;i<n;i++){
        fscanf(fpr,"%s%s%d%d",&files[i].name,fname.&files[i].type,&files[i],time);
        if(strcmp(fname,"-")==0){
            root = &files[i];
        }
        else{
            for(j=0;j<i;++j){
                if(strcmp(fname,files[j].name)==0){
					files[i].parent = &files[j];
                    files[j].link[files[j].flag++] = &flag[i];
                    
                }
            }
        }
    }
    dfs(root,0);
    qsort(results,count,sizeof(result),cmp);
    for (i = 0; i < count; ++i) {
     	print(results[i].result);
    }
    return 0;
}

int cmp(const void *a,const void *b) {
     if (((result *) a)->result->time > ((result *) b)->result->time)
        return 1;
     if (((result *) a)->result->time < ((result *) b)->result->time)
        return -1;// 按 时间升序排列
     else {
        return ((result *) a)->deep - ((result *) b)->deep;
     }// 再按深度
}
void dfs(afile *a,int deep){
	int i;
    if(a->type==0){
        if(strcmp(a->name,target)==0){
            results[count].result = a;
            results[count++].deep = deep;
        }
        return;
    }// 出口：如果找到了对应的name，放进results 里面
    else{
        for(i=0;i<a->flag;i++){
			dfs(a->link[i],deep+1);
        }
    }//否则，对当前的root的左右link dfs
}

}
// result[i]是一个结点，需要上溯
void print(afile *i){
     if (i->parent!=NULL){
     	print(i->parent);
     }// 直到找到parent;
     else{
         printf("%s:",i->namne);
         return;
     }
//打印最后一个     	printf("\\%s",i->name);
     if (i->type==0)//遇到文件,\n
     	printf("\n");
     return;
}

```

```c

#include<stdio.h>
#include<stdlib.h>
#inlcude<string.h>

#define MAX
typedef struct File{
	int time,type;
    char name[20];
    int flag ;
    struct File* link[MAX];
    struct File* parent
}afile;
afile* root,file[10000] = {}
char target[20];
typedef struct rtype{
    afile* result;
    int deep;
}result;
result results[1234];
int main(){
    FILE* fpr = fopen("files.txt","r");
    int i,j,n;
    char fname[20];
    
    
    scanf("%s",tree);
    
    scanf("%s%d",target,&n);
    for(i=0;i<n;i++){
        fscanf(fpr,"%s%s%d%d",&files[i].name,fname.&files[i].type,&files[i],time);
        if(strcmp(fname,"-")==0){
            root = &files[i];
        }
        else{
            for(j=0;j<i;++j){
                if(strcmp(fname,files[j].name)==0){
					files[i].parent = &files[j];
                    files[j].link[files[j].flag++] = &flag[i];
                    
                }
            }
        }
    }
    dfs(root,0);
    qsort(results,count,sizeof(result),cmp);
    for (i = 0; i < count; ++i) {
     	print(results[i].result);
    }
    return 0;
}

int cmp(const void *a,const void *b) {
     if (((result *) a)->result->time > ((result *) b)->result->time)
        return 1;
     if (((result *) a)->result->time < ((result *) b)->result->time)
        return -1;// 按 时间升序排列
     else {
        return ((result *) a)->deep - ((result *) b)->deep;
     }// 再按深度
}
void dfs(afile *a,int deep){
	int i;
    if(a->type==0){
        if(strcmp(a->name,target)==0){
            results[count].result = a;
            results[count++].deep = deep;
        }
        return;
    }// 出口：如果找到了对应的name，放进results 里面
    else{
        for(i=0;i<a->flag;i++){
			dfs(a->link[i],deep+1);
        }
    }//否则，对当前的root的左右link dfs
}

}
// result[i]是一个结点，需要上溯
void print(afile *i){
     if (i->parent!=NULL){
     	print(i->parent);
     }// 直到找到parent;
     else{
         printf("%s:",i->namne);
         return;
     }
//打印最后一个     	printf("\\%s",i->name);
     if (i->type==0)//遇到文件,\n
     	printf("\n");
     return;
}



```











#### 查家谱

同姓氏中国人见面常说的一句话是“我们五百年前可能是一家”。从当前目录下的文件in.txt中读入一家谱，从标准输入读入两个人的名字（两人的名字肯定会在家谱中出现），编程查找判断这两个人相差几辈，若同辈，还要查找两个人共同的最近祖先以及与他（她）们的关系远近。假设输入的家谱中每人最多有两个孩子，例如下图是根据输入形成的一个简单家谱：

![在这里插入图片描述](watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob3VFbnNoZW4=,size_16,color_FFFFFF,t_70.png)
通过该家谱，可以看到wangliang、wangguoping和wangguoan都有两个孩子，wangtian、wangxiang和wangsong有一个孩子，wangguang、wangqinian、wangping和wanglong还没有孩子。若要查找的两个人是wangqinian和wangguoan，从家谱中可以看出两人相差两辈；若要查找的两个人是wangping和wanglong，可以看出两人共同的最近祖先是wangguoan，和两人相差两辈。



从当前目录下的in.txt中读入家谱。文件中第一行是家谱中有孩子的人数，后面每行内容是每个人的名字和其孩子的名字，名字都由1到20个英文字母构成，各名字间以一个空格分隔，整个家谱中的人员都不会重名；若只有一个孩子，则第二个孩子的名字为NULL；若没有孩子，则不需输入；输入的顺序是按照辈份从高到低依次输入，若孩子A出现在孩子B之前，则A的孩子应在B的孩子之前输入。假设以该形式读入的家谱肯定能够形成类似上图所示的一棵二叉树形式的家谱，家谱中任何两人相差的辈份不会超过100。

从标准输入读入要查找的两个人的名字，两名字间也以一个空格分隔。

所有信息输出到标准输出上。

若要查找的两人不同辈，则先输出辈份低的名字，再输出辈份高的名字，然后输出相差几辈，都以一个空格分隔；

若两人同辈，按照两人名字从标准输入读取的先后顺序，分行输出两人的最近祖先名字、两人姓名以及相差几辈，各数据间以一个空格分隔。

假设当前目录下in.txt文件内容为：

6

wangliang wangguoping wangguoan

wangguoping wangtian wangguang

wangguoan wangxiang wangsong

wangtian wangqinian NULL

wangxiang wangping NULL

wangsong wanglong NULL

从标准输入读取：

wangqinian wangliang

【样例1输出】

wangqinian wangliang 3

【样例2输入】

假设当前目录下in.txt文件内容为：

6

wangliang wangguoping wangguoan

wangguoping wangtian wangguang

wangguoan wangxiang wangsong

wangtian wangqinian NULL

wangxiang wangping NULL

wangsong wanglong NULL

从标准输入读取：

wangping wanglong

【样例2输出】

wangguoan wangping 2

wangguoan wanglong 2

【样例1说明】

家谱中输入了六个人名及其孩子的人名，形成了“问题描述”中的家谱，要查找的两人是wangqinian和wangliang，wangliang比wangqinian高3辈。

【样例2说明】

和样例1同样输入了一家谱，wangping和wanglong共同的最近祖先是wangguoan，该祖先与两人相差两辈。

## 

看了一下往年的期末考试题目，**最后一题基本都是以树作为压轴题**。2016年的查家谱和2018年的网络打印机选择都涉及到的同一个算法——找最近公共祖先，所以必须掌握这个经典算法。在这里还是要说一下的是，这两个题的找最近公共祖先都是简化版的都是给你了每个节点的父亲节点（根节点除外），所以要好好利用好这个条件，让两个节点同时**回退到根节点，记录沿路的的信息，然后比对找出第一个相同信息的节点即为最近公共祖先**，当然我们必须要思考的是，如果不是这种给了父亲节点的伪线索树，我们又该如何找最近公共祖先呢？

还有一个难点是如何构造树，用递归即可，但是要注意初始化完备，不然会受到野指针的影响！

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
typedef struct TreeNode {	//树的结构体 
    char name[200];
    int depth;					//新增了层数 
    struct TreeNode *left;
    struct TreeNode *right;
    struct TreeNode *parent;	//新增了父亲节点 
}Tree,*Treep;											 //top是栈顶 
int HaveChild_parentNum,depth,chidDepth_1,chidDepth_2,flag,top,i,j;
//	有孩子的父母的个数	深度 第一个孩子的深度 第二个孩子的深度 
char parName[200],chidName_1[200],chidName_2[200];
Treep root=NULL,chidPtr_1,chidPtr_2,ancPtr,ptr,path_1[200],path_2[200];
//		第一个孩子的指针 第二个孩子的指针，祖先指针(ancPtr) 
void initTree(Treep t, int depth);	//构建树 
Treep SearchTree(Treep t,char* s);	//搜索该孩子的位置 
Treep FindSameAncestor(Treep p,Treep q);//搜索公共祖先
int main()
{	
	FILE *fp = fopen("in.txt","r");
	fscanf(fp,"%d",&HaveChild_parentNum);	//读入有孩子的父母的个数
	for(i=0;i<HaveChild_parentNum;i++)
	{
		depth=1;		//起始层数是1，不是0 
		fscanf(fp,"%s %s %s",parName,chidName_1,chidName_2);//录入信息 
		if(root==NULL)
		{
			root=(Treep)malloc(sizeof(Tree));			//申请空间 
			root->left=(Treep)malloc(sizeof(Tree));		//申请空间 
			root->right=(Treep)malloc(sizeof(Tree));	//申请空间  
			strcpy(root->name,parName);				
			strcpy(root->left->name,chidName_1);		//录入信息 
			root->left->left=root->left->right=NULL;	//一定要初始化好 
			root->depth=depth,root->left->depth=depth+1;	//录入信息 
			root->left->parent=root;
			if(strcmp(chidName_2,"NULL")!=0)	//有没有第二个孩子 
			{
				strcpy(root->right->name,chidName_2);	//录入信息 
				root->right->left=root->right->right=NULL;	//初始化 
				root->right->parent=root;	//录入信息 
				root->right->depth=depth+1;	//录入信息 
			}	
			else	root->right=NULL;	//初始化 
		}
		else
		{
			initTree(root->left,depth+1);	//递归插入 
			initTree(root->right,depth+1);	//递归插入 
		}	
	}
	scanf("%s %s",chidName_1,chidName_2);
	flag=0,ptr=NULL;
	chidPtr_1=SearchTree(root,chidName_1);	//找到第一个人的位置 
	chidDepth_1=chidPtr_1->depth;
	flag=0,ptr=NULL;
	chidPtr_2=SearchTree(root,chidName_2);	//找到第二个人的位置 
	chidDepth_2=chidPtr_2->depth;
	if(chidDepth_1 != chidDepth_2)		//层数不同 
	{
		if(chidDepth_1 < chidDepth_2)
			printf("%s %s %d\n",chidName_2,chidName_1,chidDepth_2-chidDepth_1);
		else
			printf("%s %s %d\n",chidName_1,chidName_2,chidDepth_1-chidDepth_2);
	}
	else								//层数相同 
	{
		ancPtr=FindSameAncestor(chidPtr_1,chidPtr_2);	//找到公共祖先 
		printf("%s %s %d\n",ancPtr->name,chidName_1,chidDepth_1-ancPtr->depth);
		printf("%s %s %d\n",ancPtr->name,chidName_2,chidDepth_2-ancPtr->depth);
	}
	return 0;
}
Treep FindSameAncestor(Treep p,Treep q)
{
	flag=0;
	ptr=chidPtr_1,top=0;
	while(ptr!=root)	//回退祖先，记录沿路的指针地址 
	{
		path_1[top]=ptr;	//用栈存下 
		ptr=ptr->parent,
		top++;
	}
	path_1[top]=root;
	ptr=chidPtr_2,top=0;
	while(ptr!=root)	//回退祖先，记录沿路的指针地址 
	{
		path_2[top]=ptr;	//用栈存下
		ptr=ptr->parent,
		top++;
	}
	path_2[top]=root;
	for(i=0;path_1[i];i++)		//找第一个相同的指针地址即为最近公共祖先的地址 
	{
		for(j=0;path_2[j];j++)
		{
			if(path_1[i]==path_2[j])	//找到 
				flag=1;
			if(flag==1)
				break;
		}
		if(flag==1)
			break;
	}
	return path_1[i];	//返回最近公共祖先的指针 
}
void initTree(Treep t, int depth)	//插入树，跟之前一样 
{
	if(t==NULL)	return;
	if(strcmp(t->name,parName)==0)	
	{
		t->left=(Treep)malloc(sizeof(Tree));
		t->right=(Treep)malloc(sizeof(Tree));
		strcpy(t->left->name,chidName_1);
		t->left->left=t->left->right=NULL;
		t->left->depth=depth+1;
		t->left->parent=t;
		if(strcmp(chidName_2,"NULL")!=0)
		{
			strcpy(t->right->name,chidName_2);
			t->right->left=t->right->right=NULL;
			t->right->parent=t;
			t->right->depth=depth+1;
		}	
		else	t->right=NULL;
	}
	else
	{
		initTree(t->left,depth+1);	//递归时层数+1 
		initTree(t->right,depth+1);	//递归时层数+1 
	}
}
Treep SearchTree(Treep t,char* s)
{
	if(t==NULL && flag==0)	return NULL;	//还没找着所以递归回退NULL 
	else if (t==NULL && flag==1)	return ptr;	//找着了所以返回指针 
	if(strcmp(t->name,s)==0)	//找到了 
	{
		flag=1;
		ptr=t;
		return ptr;			//返回该姓名的指针 
	}	
	else
	{
		SearchTree(t->left,s); //左子树找 
		SearchTree(t->right,s);//右子树找 
	}
}
```







#### 第六次作业



从标准输入中读入一个英文单词及查找方式，在一个给定的英文常用单词字典文件dictionary3000.txt中查找该单词，返回查找结果（查找到返回1，否则返回0）和查找过程中单词的比较次数。查找前，先将所有字典中单词读入至一个单词表（数组）中，然后按要求进行查找。字典中单词总数不超过3500，单词中的字符都是英文小写字母，并已按字典序排好序（可从课件下载区下载该字典文件）。字典中的单词和待查找单词的字符个数不超过20。

查找方式说明：查找方式以1~4数字表示，每个数字含义如下：

1：在单词表中以顺序查找方式查找，因为单词表已排好序，遇到相同的或第一个比待查找的单词大的单词，就要终止查找；

2：在单词表中以折半查找方式查找；

3：在单词表中通过索引表来获取单词查找范围，并在该查找范围中以折半方式查找。索引表构建方式为：以26个英文字母为头字母的单词在字典中的起始位置和单词个数来构建索引表，如：

| 字母 | 起始位置 | 单词个数 |
| ---- | -------- | -------- |
| a    | 0        | 248      |
| b    | 248      | 167      |
| …    | …        | …        |

该索引表表明以字母a开头的单词在单词表中的开始下标位置为0，单词个数为248。

4：按下面给定的hash函数为字典中单词构造一个hash表，hash冲突时按字典序依次存放单词。hash查找遇到冲突时，采用链地址法处理，在冲突链表中找到或未找到(遇到第一个比待查找的单词大的单词或链表结束)便结束查找。

/* compute hash value for string */

\#define NHASH 3001

\#define MULT 37

unsigned int hash(char *str)

{

​    unsigned int h=0;

​    char *p;

 

​    for(p=str; *p!='\0'; p++)

​       h = MULT*h + *p;

​    return h % NHASH;

}

提示：hash表可以构建成指针数组，hash冲突的单词形成一有序链表。

【输入形式】

单词字典文件dictionary3000.txt存放在当前目录下，待查找单词和查找方式从标准输入读取。待查找单词只包含英文小写字母，与表示查找方式的整数之间以一个空格分隔。

【输出形式】

将查找结果和单词比较次数输出到标准输出上，两整数之间以一个空格分隔。
【样例输入与输出】
单词字典文件dictionary3000.txt与课件下载中提供的相同，下面两列中，左侧为待查找单词与查找方式，右侧为对应的输出结果：

wins 1                0 3314

wins 2                0 12

wins 3                0 7

wins 4                0 2

yes 1                1 3357

yes 2                1 10

yes 3                1 4

yes 4                1 1
【样例说明】

wins在单词字典中不存在，4种查找方式都输出结果0，顺序查找、折半查找、索引查找和hash查找的单词比较次数分别为：3314、12、7和2次（wins的hash位置与字典中physics和suggest相同）。

yes在单词字典中存在，4种查找方式都输出结果1，顺序查找、折半查找、索引查找和hash查找的单词比较次数分别为：3357、10、4和1。

【评分标准】

该题要求输出查找结果和查找过程中的单词比较次数，提交程序名为find.c。



```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct Dict{
	char word[100];
};
int cnt = 0,total;
int sq_cnt,b_cnt,idx_cnt,hash_cnt;
struct Dict dict[5000];
void read_in(FILE* in){
	int i = 0;
//	fscanf()
	while(fscanf(in,"%s",dict[i].word)!=EOF){
		i++;
		cnt++;
	}	
}
void display(){
	int i = 0;
	while(i<cnt){
		printf("%s",dict[i].word);
		i++;
	}
}
void Create_idx_table();
void display_idx_table();
int sqsearch(struct Dict dict[],int n,char keys[]); 
char key[40];
int op;

int sqsearch(struct Dict dict[],int n,char key[]){
	int i;
//	printf("i:%d n:%d key%s\n",i,n,key);
	for(i=0;i<n;i++){
		sq_cnt++;
//		printf("comparing %s and %s\n",dict[i].word,key);
		if(strcmp(key,dict[i].word)==0){
//			printf("find it\n");
			return i;
		}
		else if(strcmp(key,dict[i].word)<0){
			return -1;
		}
	} 
	return -1;
}// 顺序查找

int b_search(struct Dict dict[],int l,int r,char key[]){
//	int l = 0;
//	int r = n-1;
	while(l<=r){
		b_cnt++;
		int mid = l + (r-l)/2;
		if(strcmp(dict[mid].word,key)>0){
			r = mid-1;
		}
		else if(strcmp(dict[mid].word,key)<0){
			l = mid+1;
		}
		else if(strcmp(dict[mid].word,key)==0){
			return mid;
		}
	}
	if(strcmp(dict[l].word,key)==0){	
		return l;
	}
	else {
		return -1;
	}
}// 二分查找

struct Index{
	char idx;
	int st;
	int len;
};
struct Index index_table[1000];

void Create_idx_table(){
	char idx = 'a';
	int i=0;
	index_table[idx].st = 0;
	index_table[idx].idx = idx;
	for(i=0;i<cnt;i++){
		if(dict[i].word[0]==idx){
			i++;
			continue;
		}
		else if(dict[i].word[0]!=idx){
			index_table[idx].len = i-index_table[idx].st;
			idx++;
			index_table[idx].st = i;
			index_table[idx].idx = idx;
			i--;
		}
	}
	index_table[idx].len = i-index_table[idx].st;
			idx++;
			index_table[idx].st = i;
			index_table[idx].idx = idx;
			i--;
}
void display_idx_table(){
	char idx = 'a';
	for(;idx<='z';idx++){
		printf("%c st:%d len:%d\n",idx,index_table[idx].st,index_table[idx].len);
	}
}


int bsearch_idx(struct Dict dict[],int l,int r,char key[]){
//	int l = 0;
//	int r = n-1;
	while(l<=r){
		int mid = l + (r-l)/2;
		idx_cnt++;
		if(strcmp(dict[mid].word,key)>0){
			r = mid-1;
		}
		else if(strcmp(dict[mid].word,key)<0){
			l = mid+1;
		}
		else if(strcmp(dict[mid].word,key)==0){
			return mid;
		}
	}
	if(strcmp(dict[l].word,key)==0){	
		return l;
	}
	else {
		return -1;
	}
}

int search_in_idxtable(char s[]){
	return bsearch_idx(dict,index_table[s[0]].st,index_table[s[0]].st+index_table[s[0]].len-1,s);
} 
struct Node{
	char word[100];
	struct Node* next;
};

#define NHASH  3001
#define MULT  37
unsigned int hash(char *str){
       unsigned int h=0;
       char *p;
       for(p=str; *p!='\0'; p++)
              h = MULT*h + *p;
       return h % NHASH;
}
struct Node * hash_table[5000];
void create_hash(char *s){
	struct Node* p;
	p = (struct Node*)malloc(sizeof(struct Node));
	unsigned int address = hash(s);
	strcpy(p->word,s);
	p->next = hash_table[address];
	hash_table[address] = p;
}


struct Node* hash_search(char * key){
	struct Node* q;
	unsigned int adrs = hash(key);
	q = hash_table[adrs];
	if(q == NULL){
		hash_cnt++;
	return NULL;
	}
	else{
		for(q;q!=NULL;q = q->next){
			hash_cnt++;
			if(strcmp(q->word,key)==0){
				return q;
			}
			if(strcmp(q->word,key)>0) return NULL;
		}
	}
	return NULL;
}

//创建哈希函数
//根据哈希函数创建哈希表，头插
//最后根据值找到地址，遍历-链 

int main(){
	FILE* in;
	in = fopen("dictionary3000.txt","r");
//	printf("open\n");
	int i = 0;
	int j;
	int ans= 0;
	read_in(in);
//	display();
//	total = cnt;
	Create_idx_table();	
//	display_idx_table();
	for(j=0;j<cnt;j++){
		create_hash(dict[j].word);
	}
	
	while(scanf("%s %d",key,&op)==2){
		if(op==1){
			ans = sqsearch(dict,cnt,key);
//			printf("pos %d\n",ans); 
			if(ans!=-1){
				printf("1 %d\n",sq_cnt);
			}
			else printf("0 %d\n",sq_cnt);
			sq_cnt = 0;
		}
		if(op==2){
			ans= b_search(dict,0,cnt-1,key);
			if(ans !=-1){
				printf("1 %d\n",b_cnt);
			}
			else printf("0 %d\n",b_cnt);
			b_cnt = 0;
		}
		if(op==3){
			ans = search_in_idxtable(key);
			if(ans !=-1){
				printf("1 %d\n",idx_cnt);
			}
			else printf("0 %d\n",idx_cnt);
			idx_cnt = 0;
		}
		if(op==4){
			struct Node * t;
			t = hash_search(key);
			if(t !=NULL){
				printf("1 %d\n",hash_cnt);
			}
			else printf("0 %d\n",hash_cnt);
			hash_cnt = 0;
		}
		
	}
//	display();	
}
 
//wins 1
//wins 2
//wins 3
//wins 4
//yes 1
//yes 2
//yes 3
//yes 4


```



```c

#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define max(a,b) a>b?a:b
#define min(a,b) a<b?a:b
struct Table{
	char name[100];
	char id[15];
    int seat_num;
};
struct Table stdlist[1000];
int check[1000];
int total = 0;
int blanklist[100];
int blank = 0;

void set_seat_of_a_as_b(int a,int b);
int cmp(const void *a, const void*b);
int cmp2(const void *a, const void*b);
void move_a_to_b(int a,int b);
int main(){
	FILE * in,*out;
    in = fopen("in.txt","r");
    int max_seat = 0;
    int i = 0;
    scanf("%d",&total);
    while(fscanf(in,"%s %s %d",stdlist[i].id,stdlist[i].name,&stdlist[i].seat_num)!=EOF){
		max_seat = max(max_seat,stdlist[i].seat_num);
        i++;
    }
    
    qsort(stdlist,total,sizeof(struct Table),cmp);//按座位号 升序 排序
	int last = total - 1;
	int q = min(max_seat,total);
	for(i=0;i<total;i++){
		check[stdlist[i].seat_num]++;
	} 
	int j;
	for(j=1;j<=q;j++){
		if(check[j]==0){
			stdlist[last].seat_num = j;
			last --;
			q = min(stdlist[last].seat_num,total);
		}
	}
//	for(i=0;i<total;i++){
//		printf("%s %s %d\n",stdlist[i].id,stdlist[i].name,stdlist[i].seat_num);
//	}
	max_seat = stdlist[last].seat_num;
	for(i=0;i<total;i++){
		if(stdlist[i].seat_num==stdlist[i+1].seat_num){
			max_seat++;
			if(strcmp(stdlist[i+1].id,stdlist[i].id)>0){
				stdlist[i+1].seat_num = max_seat;
			}
			else stdlist[i].seat_num = max_seat;
		}
	}
	qsort(stdlist,total,sizeof(struct Table),cmp2);//按座位号 升序 排序
	out = fopen("out.txt","w");
	for(i=0;i<total;i++){
		fprintf(out,"%s %s %d\n",stdlist[i].id,stdlist[i].name,stdlist[i].seat_num);
	}
	
//	for(i=0;i<total;i++){
//		printf("%s %s %d\n",stdlist[i].id,stdlist[i].name,stdlist[i].seat_num);
//	}

} 
void set_seat_of_a_as_b(int a,int b){
	stdlist[a].seat_num = b;
} 
//
//void move_a_to_b(int a,int b){
//    stdlist[a].seat_num = b;
////    q--;
//}

int cmp(const void *a, const void*b){
	struct Table* x = (struct Table *)a;
	struct Table* y = (struct Table *)b;
	if(x->seat_num>y->seat_num){
		return 1;
	}
	else if(x->seat_num<y->seat_num){
		return -1;
	}
	else{
		if(x->id<y->id) return 1;
		else return -1;
	}
}
int cmp2(const void *a, const void*b){
	struct Table* x = (struct Table *)a;
	struct Table* y = (struct Table *)b;
	if(strcmp(x->id,y->id)>0){
		return 1;
	}else return -1;
}
```

##### 排序方法总结





【问题描述】

从标准输入中输入一组互不相同的整数（个数不超过100）及排序方式，按照从小到大排序，输出按某种算法排序的结果及元素的比较次数。

说明：排序方式为一个1~5的整数，分别表示：

1：选择排序，比较次数是指选择未排序部分的最小元素时的比较次数。

2：冒泡排序，比较次数是指相邻元素的比较次数，若某趟排序中没有进行数据交换，就认为排序结束。

3：堆排序，比较次数是指根元素调整过程中根元素与子树根结点的比较次数，即下面算法中红色语句的执行次数：

void adjust(int k[ ],int i,int n)

{

  int j,temp;

  temp=k[i];

  j=2*i+1;

  while(j<n){

​    if(j<n-1 && k[j]<k[j+1])

​      j++;

​    if(temp>=k[j]) 

​      break;

​    k[(j-1)/2]=k[j];

​    j=2*j+1;

  }

  k[(j-1)/2]=temp;

}

4：二路归并排序，比较次数是指两组有序数据合并成一组时的比较次数，即下面算法中红色语句的执行次数（注意：调用 merge时，要使用上课讲的递归算法）：

void merge(int x[ ],int tmp[ ],int left,int leftend,int rightend)

{   

  int i=left, j=leftend+1, q=left;

  while(i<=leftend && j<=rightend)

  {

​    if(x[i]<=x[j]) 

​      tmp[q++]=x[i++];

​    else

​      tmp[q++]=x[j++];

  }

  while(i<=leftend)

​    tmp[q++]=x[i++];

  while(j<=rightend)

​    tmp[q++]=x[j++];

  for(i=left; i<=rightend; i++)

​    x[i]=tmp[i];

}

5：快速排序，比较次数是指分界元素与其它元素的比较次数，即下面算法中红色语句的执行次数：

void quickSort(int k[ ],int left,int right)

{   

  int i, last;

  if(left<right){

​    last=left; 

​    for(i=left+1;i<=right;i++)

​      if(k[i]<k[left])

​        swap(&k[++last],&k[i]); 

​    swap(&k[left],&k[last]);

​    quickSort(k,left,last-1); 

​    quickSort(k,last+1,right);  

  }

}

【输入形式】

首先在屏幕上输入2个整数，分别表示待排序的整数个数及排序方式，然后在下一行依次输入待排序的整数。各整数之间都以一个空格分隔。

【输出形式】

先在一行上输出排序结果，各整数间以一个空格分隔。然后在下一行上输出排序过程中的元素比较次数。

【样例1输入】

20 1
38 356 98 -102 126 46 65 -9 100 0 21 2 90 8 18 12 78 16 189 23

【样例1输出】

-102 -9 0 2 8 12 16 18 21 23 38 46 65 78 90 98 100 126 189 356
190

【样例1说明】

输入了20个整数数据，要求按照选择排序算法对输入的数据进行从小到大排序，输出排序结果，排序过程中元素的比较次数为190次。

【其它样例说明】

若输入的待排序数据与样例1完全相同，要求的排序算法不同，则输出的排序结果与样例1完全一样，但比较次数不同，为了方便说明，下面左侧为排序方式，右侧为对应的比较次数：

2      162

3      58

4      66

5      75

【评分标准】

该题要求按照指定算法对输入的数据进行排序，提交程序名为sort.c。

```c
#include<stdio.h>
int a[200];
int select_cnt = 0,bubble_cnt = 0,heap_cnt = 0,merge_cnt = 0,quick_cnt = 0;
void adjust(int k[ ],int i,int n);
void build_max_heap(int arr[], int total);
void heapify(int arr[],int total,int current);
void swap(int *xp, int *yp){
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void bubblesort(int arr[], int l,int r)
{
    int i, j,changed = 0;
    for (i = l; i < r; i++){
	    changed = 0;
	    // Last i elements are already in place
        for (j = 0; j < r - i; j++){
        	bubble_cnt++;
            if (arr[j] > arr[j + 1]){
                swap(&arr[j], &arr[j + 1]);
                changed = 1;
			}
		}
		if(changed == 0) break;
	}
}

void selectionsort(int arr[],int l,int r){
    int i,num_sorted = 0,j;
    int min_pos;
 	for(i=l;i<r;i++){
        min_pos = i;
        for(j = i+1;j<=r;j++){
           	select_cnt++; 
            if(arr[j]<arr[min_pos]){
                min_pos = j;
            }
          
        }//找到了最小值
          if(min_pos != i){
                swap(&arr[i],&arr[min_pos]);
        }
    }
}


//10
//5 2 3 1 2 2 2 1 1 9

//20
//5 2 3 1 2 2 2 1 1 9 3 8 6 7 7 7 3 2 -12 23 

//10
//1 1 1 1 1 2 1 1 1 1


//5
// 1 1 2 1 1 
void build_max_heap(int arr[], int total){   
	int startIdx = (total / 2) - 1;
 //目前整个堆的根：对这个根进行heapify
 //最后一个不是叶子结点的序号，因为，只对"根"heapify有用
 int i = 0;
    for (i = startIdx; i >= 0;i--) {
        adjust(arr, i, total);
    }//对有共有N个节点的堆中的子节点i的进行heapify
}
void heapsort(int arr[], int total) 
{
   build_max_heap(arr,total);//首先需要建立一个大顶堆，但是一个大顶堆只能保证根节点最大，并不有序。
    //因此需要继续调整
    int i = total -1;
    for(i;i>0;i--){
        swap(&arr[0],&arr[i]);
        total--;
        adjust(arr,0,total);
    }
}

void adjust(int k[ ],int i,int n){//对有n个元素的堆里,idx为i的进行回答。 
    int j,temp;
    temp=k[i];
    j=2*i+1;
    while(j<n){
         heap_cnt++; 
		if(j<n-1 && k[j]<k[j+1]){
            j++;
    	}
		if(temp>=k[j]){
            break;
    	}
		k[(j-1)/2]=k[j];
        j=2*j+1;
    }
    k[(j-1)/2]=temp;
}
int tmp[1000] = {0};
void merge(int x[ ],int tmp[ ],int left,int leftend,int rightend){     
    int i=left, j=leftend+1, q=left;
    // [left ----- leftend] (---   rightend]
    while(i<=leftend && j<=rightend){
        merge_cnt++;
		if(x[i]<=x[j]) {
            tmp[q++]=x[i++];
		}//temp 是 [ ] ( ] 的merge 
        else
            tmp[q++]=x[j++];
    }
    while(i<=leftend){
        tmp[q++]=x[i++];
	}
	while(j<=rightend){
        tmp[q++]=x[j++];
	}//补上剩下的。 
	for(i=left; i<=rightend; i++){
        x[i]=tmp[i];
	}//更新。 
}
void mergesort(int arr[], int l, int r){
    if (l < r) {
        int m = l + (r - l) / 2;
        mergesort(arr, l, m);
        mergesort(arr, m + 1, r);
 //先分，再归并。
        merge(arr, tmp,l, m, r);
    }
}
void quickSort(int k[ ],int left,int right){     
    int i, last;
    if(left<right){
        last=left; 
        for(i=left+1;i<=right;i++){
        	quick_cnt++;
            if(k[i]<k[left])
                swap(&k[++last],&k[i]); 
    	}
		swap(&k[left],&k[last]);
        quickSort(k,left,last-1); 
        quickSort(k,last+1,right);   
    }
}
//int main(){
//	int i,j,n;
//	int op;
//	scanf("%d",&n);
//	for(i=0;i<n;i++){
//		scanf("%d",&a[i]);
//	}
////	selectionsort(a,0,n-1);
////	bubblesort(a,0,n-1);
//
//	for(int i=0;i<n;i++){
//		printf("%d ",a[i]);
//	}
//	
////	mergesort(a,0,n-1);
//	quickSort(a,0,n-1);	
//	printf("\n");
////	heapsort(a,n);
//	for(int i=0;i<n;i++){
//		printf("%d ",a[i]);
//	}	
//}

int b[1000];
int not_equal = 0;
int main(){
	int i,j,n;
	int op;
	while(scanf("%d %d",&n,&op)!=EOF){
		for(i=0;i<n;i++){
			scanf("%d",&a[i]);
		}
		for(i=0;i<n;i++){
			if(b[i]!=a[i]){
				not_equal = 1;
			}
		}
		for(i=0;i<n;i++){
			b[i] = a[i]; 
		}
		if(not_equal){
			if(op==1){
				selectionsort(a,0,n-1);
				for(i=0;i<n;i++){
					printf("%d ",a[i]);
				}
				printf("\n");
				printf("%d\n",select_cnt);
				select_cnt = 0;
			}
			else if(op==2){
				bubblesort(a,0,n-1);
				for(i=0;i<n;i++){
					printf("%d ",a[i]);
				}
				printf("\n");
				printf("%d\n",bubble_cnt);	
				bubble_cnt = 0;
			}
			else if(op==3){
				heapsort(a,n);
				for(i=0;i<n;i++){
					printf("%d ",a[i]);
				}
				printf("\n");
				printf("%d\n",heap_cnt);
				heap_cnt = 0;
			}
			else if(op==4){
				mergesort(a,0,n-1);
				for(i=0;i<n;i++){
					printf("%d ",a[i]);
				}
				printf("\n");
				printf("%d\n",merge_cnt);
				merge_cnt = 0;
			}
			else if(op==5){
				quickSort(a,0,n-1);
				for(i=0;i<n;i++){
					printf("%d ",a[i]);
				}
				printf("\n");
				printf("%d\n",quick_cnt);
				quick_cnt = 0;
			}
		}
		else{
				if(op==1){
				selectionsort(a,0,n-1);
				printf("1 %d\n",select_cnt);
				select_cnt = 0;
			}
			else if(op==2){
				bubblesort(a,0,n-1);
				printf("2 %d\n",bubble_cnt);	
				bubble_cnt = 0;
			}
			else if(op==3){
				heapsort(a,n);
				printf("3 %d\n",heap_cnt);
				heap_cnt = 0;
			}
			else if(op==4){
				mergesort(a,0,n-1);
				printf("4 %d\n",merge_cnt);
				merge_cnt = 0;
			}
			else if(op==5){
				quickSort(a,0,n-1);
				printf("5 %d\n",quick_cnt);
				quick_cnt = 0;
			}
		}
		not_equal = 0;
	}
}




```





##### 函数调用关系

给定某能正常运⾏结束的⽤户函数调⽤栈信息（当⼀个函数被调⽤时将⼊栈，当调⽤返回时，将出栈）。编写程序，对函数调⽤栈信息进⾏分析，依据函数⼊栈和出栈信息，分析函数调⽤关系，即⼀个函数调⽤了哪些不同函数。并按运⾏时调⽤序输出调⽤关系。

说明：

1. 在⼀个函数中，同⼀函数有可能被调⽤多次，输出调⽤关系时只输出⼀次；若⼀个函数没有调⽤其它函数，则不输出调⽤关系；
2. 函数运⾏时调⽤序是指函数在调⽤栈中的出现序。
3. 程序中不存在递归调⽤。函数名符合C语⾔标识符的规定，函数名⻓度不超过20，每个函数最多调⽤不超过10个不同函数，程序中⽤户定义的函数个数不超过100。

算法提示：当⼀个函数⼊栈时，它就是当前栈顶函数调⽤的⼀个函数。

【输⼊形式】

假设⽤8表示函数⼊栈操作；⽤0表示当前函数出栈。当操作为8（⼊栈）时，输⼊形式为：

<操作> <函数名>

当操作为0（出栈）时，输⼊形式为：

<操作>

所有⼊栈操作和出栈操作都是从标准输⼊分⾏输⼊，假设调⽤栈中函数个数最多不超过200。开始时，调⽤栈为空，当调⽤栈再次为空时，输⼊结束。

【输出形式】

按运⾏时调⽤先后顺序输出函数调⽤关系到标准输出，每⾏为⼀个函数的调⽤关系信息，包括：函数名及被调⽤函数，函数与被调⽤函数间⽤⼀个英⽂冒号“:”分隔，被调⽤函数间⽤⼀个英⽂逗号“,”分隔，最后⼀个函数名后跟⼀个回⻋。若⼀个函数没有调⽤其它函数，则不输出。

【样例输⼊】

8 main
8 input
0
8 mysqrt
0
8 findA
0
8 findB
8 area
8 mysin
0
8 mycos
0
8 mysqrt
0
0
0
8 findC
8 area
8 mysin
0
0
8 mysqrt
8 max
0
0
0
8 output
0
0

【样例输出】

main:input,mysqrt,findA,findB,findC,ouput
mysqrt:max
findB:area
area:mysin,mycos,mysqrt
findC:area,mysqrt

【样例说明】

按照运⾏时调⽤函数的先后顺序，依次输出了main、mysqrt、findB、area和findC的函数调⽤关系。其中main函数调⽤了6个函数，按照运⾏时调⽤序依次输出。注意：mysqrt函数先于findB等函数出现在栈中，虽然mysqrt调⽤max较晚，但要先输出其调⽤关系。

```c
#include<stdio.h>
#include<string.h>
struct M{
    char name[20];
}main_stack[1000],stack[1000][30];
int a,b,c;


int t = -1;// MAIN_STACK
int tt = -1;// STAKC
//struct Info{
//    char name[];
//    int idx;
//}info[1000];
int main_cnt=0;
int totalfunc=0;
int func_num[1000] = {0};
char fname[30] = {0};
int search(char s[],struct M stack[1000][30]){
	int i;
	for(i=0;i<totalfunc;i++){
        printf("stack cmp:%s %s\n",stack[i][0].name,s);
		if(strcmp(s,stack[i][0].name)==0){
			return i;
		}
	}
	return -1;
} 
int instack(char s[],int idx){
	int i;
	for(i=0;i<func_num[idx];i++){
		if(strcmp(s,stack[idx][i].name)==0){
			return 1;
		}
	}
	return 0;
}
int main(){
	int op;
	int i,j,k,idx;
	for(a=0;a<1000;a++){
		memset(main_stack[a].name,0,sizeof(main_stack[a].name));
	}

    for(a=0;a<1000;a++){
        for(b=0;b<30;b++){
            memset(stack[a][b].name,0,sizeof(stack[a][b].name));
        }
    }
    scanf("%d",&op);
    if(op==8){
    	printf("op==8\n");
    	scanf("%s",fname);
    	printf("fname:%s\n",fname);
        idx = search(fname,stack);
        if(idx==-1) {
			totalfunc++;
			++tt;
        	strcpy(stack[tt][func_num[tt]].name,fname);
//        	printf("%s %s\n",stack[tt][func_num[tt]].name,fname);
        	func_num[tt]++;
		}
		else{		
	        strcpy(stack[idx][func_num[idx]].name,fname);
	        func_num[idx]++;
		}
		// 不重复，则是新的函数名称，++；
		//同时进入主函数站，被用;
		
		++t;
        strcpy(main_stack[t].name,fname);
        
//      stack[++tt][func_num[tt]] = fname;
        //同时，多了一个名字，且，该函数的后面的跟着的函数的次数++； 
//        func_num[tt]++;
    }
    else if(op==0) return -1;


    while(t!=-1){// 主栈不为-1 
         scanf("%d",&op);
        if(op==8){
            scanf("%s",fname);
	    	printf("fname:%s\n",fname);
            idx = search(fname,stack);
        	if(idx==-1) {
				totalfunc++;
				strcpy(stack[++tt][func_num[tt]].name,fname);
				func_num[tt]++;
			}
        	//同样检查新进来的函数是否之前加入过 
        	t++;
			strcpy(main_stack[t].name,fname);
        	
//            main_stack[++t] = fname;
            //进入主站 
            idx = search(main_stack[t-1].name,stack);// stack[i][0];
            printf("idx = %d\n",idx);
//                stack[idx][func_num[idx]++] = fname;

        	printf("before %s %s\n",stack[tt][func_num[tt]].name,fname);
        	if(!instack(fname,idx)){
			
	            strcpy(stack[idx][func_num[idx]].name,fname);
				func_num[idx]++;
			}
        	printf("after %s %s\n",stack[tt][func_num[tt]].name,fname);
            //除了已经加入的主函数
			//要把这个加入其他调用它的函数的后面 
//            stack[++tt][func_num[tt]] = fname;

        }
        else if(op==0){
//                int index;
//                char last_name[20];
//                
//                strcpy(last_name,main_stack[t].s);
                //得到栈顶的元素名称 
                t--;
                //退栈 
//            for(i=0;i<totalfunc;i++){
//                index = search_last(lastname,stack[i][func_num[i]-1]);
//                if(index!=-1){
//                    func_num[i]--;
//                }
//            }
        }
        
    }
    
         printf("totol %d\n",totalfunc);
    for(i=0;i<totalfunc;i++){
        if(func_num[i]>1){
        	printf("%s:",stack[i][0].name);
            for(j=1;j<func_num[i]-1;j++){
            	printf("%s,",stack[i][j].name);
			}
			printf("%s",stack[i][j].name);
		
			printf("\n");   
        }
//        else{
//        	printf("%d\n",func_num[i]);
//		} 
    }
}

//8 main
//8 input
//0
//8 mysqrt
//0
//8 findA
//0
//8 findB
//8 area
//8 mysin
//0
//8 mycos
//0
//8 mysqrt
//0
//0
//0
//8 findC
//8 area
//8 mysin
//0
//0
//8 mysqrt
//8 max
//0
//0
//0
//8 output
//0
//0



//8 main
//8 input
//0
//8 input
//0
//8 input
//0
//8 put
//0
//8 input
//0
//0


```

